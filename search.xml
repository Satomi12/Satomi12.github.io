<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F07%2F22%2Fserialize%2F</url>
    <content type="text"><![CDATA[Java序列化在网络传输中经常用到，除此之外有时也用于将对象保存至文件中，例如将从数据库中读取的对象保存到硬盘中以减少数据库的查询次数，实现了缓存的目的。 Serializable接口java中只要实现了Serializable这个标记接口就可以序列化。 public class SerializeClass implements Serializable {...} Java序列化首先创建一个Student类。 public class Student implements Serializable { private transient int id; private String name; private String phoneNumber; private static Student instance; public static Student getInstance() { if (instance == null) { synchronized (Student.class) { if (instance == null) { instance = new Student(1, "qw", "1234567890"); } } } return instance; } public Student(int id, String name, String phoneNumber) { this.id = id; this.name = name; this.phoneNumber = phoneNumber; } private void writeObject(ObjectOutputStream out) throws Exception { out.defaultWriteObject(); out.writeObject(this.id); } private void readObject(ObjectInputStream in) throws Exception { in.defaultReadObject(); this.id = (int) in.readObject(); } private Object readResolve() { return instance; } @Override public String toString() { return id + " " + name + " " + phoneNumber; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet文件上传]]></title>
    <url>%2F2019%2F07%2F09%2Fupload%2F</url>
    <content type="text"><![CDATA[环境Servlet文件上传需要commons-fileupload和commons-io两个包，下载完以后导入到Idea项目中。 上传页面在WEB-INF目录下新建一个upload.jsp文件，代码如下： 12345678910111213141516&lt;%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align="center"&gt;文件上传&lt;/h1&gt;&lt;form method="post" action="/servletupload" enctype="multipart/form-data"&gt; 学号&lt;input type="text" name="id"/&gt;&lt;br/&gt; 姓名&lt;input type="text" name="name"/&gt;&lt;br/&gt; 选择文件&lt;input type="file" name="file"/&gt;&lt;br/&gt; &lt;input type="submit" value="submit"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 注意这里表单的method必须是post，因为传输的是二进制数据，而且文件是不可能添加到url后面传输的。表单中有文件传输时，enctype也必须为multipart/form-data，它表示指定传输数据为二进制类型，如图片、mp3等。 文件上传API当表单获取到用户的输入以后，转向action指定的Servlet进行后台处理。 DiskFileItemFactory存在于fileupload包下面的DiskFileItemFactory类是创建FileItem对象的工厂，可以对它进行一些配置，在解析生成FileItem对象时需要用到。这个工厂类常用的方法有： setSizeThreshold(int sizeThreshold)：设置阀值，当文件大小小于该阀值时，文件直接存到内存中；超过该阀值时，会将文件临时存储到磁盘缓冲区中。 setRepository(File repository)：指定临时文件目录，可以采用默认值System.getProperty(“java.io.tmpdir”)。 DiskFileItemFactory(int sizeThreshold, file repository)：构造方法可以接收阀值和临时文件目录。 ServletFileUpload该类负责处理上传的文件，可以将request请求中的表单输入项解析成一个个FileItem对象，然后利用FileItem对象进行后续处理。在创建ServletFileUpload对象时需要指定之前创建的工厂对象DiskFileItemFactory，以便之后解析为FileItem对象时使用。 常用的方法有： 方法 用途 boolean isMultipartContent(HttpServletRequest req) 判断上传表单是否为multipart/form-data类型 List parseRequest(HttpServletRequest req) 解析request中的表单输入项，返回一个List setFileSizeMax(long fileMaxSize) 设置上传的单个文件的最大值，单位是字节 setSizeMax(long maxSize) 设置表单数据的总大小 之所以要设置上传文件的最大值，是为了防止客户端恶意上传超大文件来浪费服务器端的存储空间。 FileItemServletFileUpload解析request后将数据封装在FileItem对象中，我们可以利用该文件来获取输入，亦或是将文件数据写入文件。注意，非文件数据也会被封装到FileItem中，只要其在表单之中。 常用方法： 方法 用途 boolean isFormField() 判断FileItem对象封装的是普通文本表单字段，还是一个文件表单字段 String getName() 获取文件上传字段的文件名，不同浏览器中获取的文件名可能不一样 write(File file) 用于将FileItem对象中的数据写入到服务器端的某个文件中 String getString() 将FileItem中保存的数据流以一个字符串形式返回 delete() 清空FileItem对象中存放的内容 后台Servlet文件上传主要分为以下3个步骤： 创建DiskFileItemFactory对象，设置阀值大小和临时文件目录。 创建ServletFileUpload对象，设置上传文件大小以及表单总大小，解析HttpServletRequest得到List对象 遍历List，对于每一个FileItem执行处理，如果是文件数据，则将其写入指定文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.List;public class UploadServlet extends HttpServlet &#123; private final String UPLOAD_DIRECTORY = "upload"; private final int MAX_FILE_SIZE = 1024*1024*40; private final int MAX_SIZE = 1024*1024*50; private final int MEMORY_THROSHOLD = 1024*1024*10; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建DiskFileItemFactory DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(MEMORY_THROSHOLD); factory.setRepository(new File(System.getProperty("java.io.tmpdir"))); //创建ServletFileUpload ServletFileUpload upload = new ServletFileUpload(factory); upload.setFileSizeMax(MAX_FILE_SIZE); upload.setSizeMax(MAX_SIZE); upload.setHeaderEncoding("UTF-8"); String uploadPath = req.getServletContext().getRealPath("/") + UPLOAD_DIRECTORY; File dir = new File(uploadPath); //不存在目录，则创建 if (!dir.exists()) &#123; dir.mkdir(); &#125; try &#123; List&lt;FileItem&gt; items = upload.parseRequest(req); //处理FileItem for (FileItem item : items) &#123; //普通文本表单字段 if (item.isFormField()) &#123; String name = item.getFieldName(); String value = item.getString("UTF-8"); System.out.println("name: " + name + ", value: " + value); &#125; else if (item.getSize() &gt; 0) &#123; String fileName = new File(item.getName()).getName(); String filePath = uploadPath + File.separator + fileName; File storeFile = new File(filePath); item.write(storeFile); req.setAttribute("message", "文件上传成功！"); &#125; else &#123; //没有上传附件的情况 req.setAttribute("message", "没有上传文件！"); &#125; &#125; &#125; catch (Exception e) &#123; req.setAttribute("message", "错误信息：" + e.getMessage()); &#125; //上传处理完毕后跳转页面 req.getServletContext().getRequestDispatcher("/message.jsp").forward(req, resp); &#125;&#125; 其他代码创建message.jsp文件并输入以下代码： 1234567891011&lt;%@page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" language="java" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Message&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 align="center"&gt;$&#123;message&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; web.xml中增加以下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;upload&lt;/servlet-name&gt; &lt;!--xxxx处填写包名--&gt; &lt;servlet-class&gt;xxxx.UploadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;upload&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletupload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 运行在Idea中运行项目(Tomcat要配置好)，然后在浏览器上输入http://localhost:8080/upload.jsp，可以看到如下界面： 点击提交后： 在Idea中可以看到文件成功上传了：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用JavaMail API发送邮件]]></title>
    <url>%2F2019%2F07%2F08%2Fjavamail%2F</url>
    <content type="text"><![CDATA[我们平时在一个网站上注册时，经常是收到一封邮件，然后获取里面的验证码或者直接点击邮件里面的链接来完成注册。这个过程是怎么实现的呢？ 回忆一下计算机网络中的邮件发送，我们是在客户端上利用smtp协议将邮件传输到smtp服务器上，然后该smtp服务器将邮件发送到目标smtp服务器上，最后收件方用IMAP或者POP3协议从其smtp服务器上拉取邮件。 环境配置首先需要下载两个jar包：Java Mail API和Java Activation Framework（JAF）。 然后分别将其导入Idea的External Libraries（本地开发）中和WEB-INF/lib（部署）文件夹下。 JavaMail APIJavaMail API主要包含4个类： Message类：javax.mail.Message类表示一封电子邮件，发送时需要先将邮件内容封装到该类中。 Transport类：javax.mail.Transport，顾名思义就是就来发送Message对象到smtp服务器上。 Session类：javax.mail.Session，主要有两个作用，一是用来配置应用程序需要的环境信息，如主机名、端口号；二是用来建立客户端与smtp服务器之间的会话信息。Message对象和Transport对象的创建都需要用到Session对象。 Store类：javax.mail.Store，接收邮件的API类，作用和发送邮件时的Transport类相对，将获取到的邮件数据封装到Message中。 创建Session对象Transport对象和Message对象均依赖于Session对象，因此我们必须首先创建Session对象。 1234567891011121314151617public Session getSession() &#123; Properties props = new Properties(); //协议 props.setProperty("mail.transport.protocol", "smtp"); //主机名 props.setProperty("mail.host", "smtp.qq.com"); //端口号，qq的smtp服务器端口号为465或587 props.setProperty("mail.smtp.port", "465"); //认证 props.setProperty("mail.smtp.auth", "true"); props.setProperty("mail.smtp.ssl.enable", "true"); //是否在控制台显示调试信息 props.setProperty("mail.debug", "true"); return Session.getInstance(props);&#125; 创建Message对象MimeBodyPart和MimeMultipartMessage对象的内容可以看成是由一个个结点组成的，这其中涉及到两个类：MimeBodyPart和MimeMultipart。 一个MimeBodyPart代表一个结点，MimeMultipart代表多个MimeBodyPart结点，这就意味着我们可以将多个MimeBodyPart结点组合成一个结点：比如正文中有多种类型的信息（文本，图片，视频等）会很有用。 此外，多个MimeBodyPart之间也可以设置关联信息，如下： 123456789101112131415+------------------------- multipart/mixed ----------------------------+| || +----------------- multipart/related ------------------+ || | | || | +----- multipart/alternative ------+ +----------+ | +------+ || | | | | 内嵌资源 | | | 附件 | || | | +------------+ +------------+ | +----------+ | +------+ || | | | 纯文本正文 | | 超文本正文 | | | || | | +------------+ +------------+ | +----------+ | +------+ || | | | | 内嵌资源 | | | 附件 | | | | +----------------------------------+ +----------+ | +------+ || | | || +------------------------------------------------------+ || |+----------------------------------------------------------------------+ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public MimeMessage getMessage(Session session, HttpServletRequest req) throws MessagingException &#123; MimeMessage message = new MimeMessage(session); //主题 message.setSubject("Subject"); message.setFrom("1034271380@qq.com"); //多个收件人用setRecipients message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress("licdftl@gmail.com")); //文本结点 MimeBodyPart text = new MimeBodyPart(); text.setContent("这是一张图片&lt;br/&gt;&lt;p&gt;&lt;img src='http://pt138cevn.bkt.clouddn.com/Celebi.png' width='200' height='200'/&gt;&lt;/p&gt;&lt;br/&gt;", "text/html; charset=UTF-8"); //当前网站的绝对路径 String curPath = req.getServletContext().getRealPath("/"); //图片结点 MimeBodyPart image = new MimeBodyPart(); DataHandler handler = new DataHandler(new FileDataSource(curPath + "WEB-INF/classes/Garchomp.png")); image.setDataHandler(handler); image.setContentID("garchomp"); //文本+图片结合 MimeMultipart content = new MimeMultipart(); content.addBodyPart(text); //图片并没有按照预期显示在正文中，而是存在于附件中，暂时还不知道为什么，图片只好先使用外链 //content.addBodyPart(image); //content.setSubType("related"); //附件结点 MimeBodyPart attach = new MimeBodyPart(); DataHandler docx = new DataHandler(new FileDataSource(curPath + "WEB-INF/classes/wiki.docx")); attach.setDataHandler(docx); //附件名字要加上后缀 attach.setFileName("MyWiki.docx"); //MimeMultipart中由MimeBodyPart组成，因此封装先前的MimeMultipart MimeBodyPart body = new MimeBodyPart(); body.setContent(content); //组合之前的MimeBodyPart MimeMultipart pub = new MimeMultipart(); pub.addBodyPart(body); pub.addBodyPart(attach); pub.setSubType("mixed"); message.setContent(pub); message.setSentDate(new Date()); return message;&#125; 这里邮件发送的是带图片和附件的邮件，除此之外还可以发送html邮件，只需要在setContent中嵌入html代码即可，另外其他Mime支持的文件也可以传输。 发送邮件发送邮件的过程就很简单了： 利用Session对象创建Transport对象 Transport对象链接smtp服务器 发送邮件 1234567891011121314151617@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Session session = getSession(); try &#123; MimeMessage message = getMessage(session, req); Transport transport = session.getTransport(); //注意这里的密码不是邮箱密码，而是授权码（qq邮箱采用） transport.connect("1034271380@qq.com", "xnrweuodmwfdbcfg"); transport.sendMessage(message, message.getAllRecipients()); transport.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 可能遇到的问题 密码：有的邮箱采用独立密码，有的采用授权码（qq邮箱） smtp服务：有的时候发送不成功，可能是因为邮箱的smtp服务没打开 收件箱收不到邮件，也许是被当成垃圾邮件拒收了，可能可以在垃圾箱中找到也可能找不到，可以换个收件箱试试]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaMail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql中where 1=1和where 1=0的作用]]></title>
    <url>%2F2019%2F07%2F02%2FMysqlWhere%2F</url>
    <content type="text"><![CDATA[有时候可以在别的代码中看到where 1=1，这究竟是什么意思，又有什么作用，本文来探讨一下这个问题。 where 1=1的应用，不是什么高级的应用，也不是所谓的智能化的构造，仅仅只是为了满足多条件查询页面中不确定的各种因素而采用的一种构造一条正确能运行的动态SQL语句的一种方法。 where 1=1的作用1=1永远成立，因此where 1=1是始终成立的。 所以SELECT * FROM table WHERE 1=1等同于SELECT * FROM table。 不用where 1=1在多条件查询中的存在的问题假如做查询页面，并且让用户自行输入查询信息email和address。则可以使用查询语句的动态构造： 1234567String sql = "SELECT * FROM table WHERE";if(email.length()&gt;0)&#123; sql=sql+" email="+'\''+email+'\'';&#125;if(address.length()&gt;0)&#123; sql=sql+" AND address="+'\''+address+'\'';&#125; 如果email为空，address不为空会出现什么情况？ 此时查询语句为SELECT * FROM table WHERE AND address=xxx，这条查询语句非法，查询出错。 如果email和address的长度均为空的话会怎么样呢？ 此时查询语句会变为：SELECT * FROM table WHERE，这显然也是一条非法的SQL语句，查询会出错。 可见，这种写法是存在一些问题的。 where 1=1的妙用稍微修改一下代码就可以避免上述错误： 1234567String sql = "SELECT * FROM table WHERE 1=1";if(email.length()&gt;0)&#123; sql=sql+" AND email="+'\''+email+'\'';&#125;if(address.length()&gt;0)&#123; sql=sql+" AND address="+'\''+address+'\'';&#125; 完美地解决了上述问题！ where 1=0where 1=0，这个条件始终不满足，结果不会返回任何数据，只有表结构，适合用来快速建表。 1CREATE TABLE newtable AS SELECT * FROM oldtable WHERE 1=0;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 连接数据库]]></title>
    <url>%2F2019%2F07%2F02%2FJDBC%2F</url>
    <content type="text"><![CDATA[数据库种类繁多，如何能有效地连接数据库？本文介绍 JDBC API 的使用方法。首先什么是 JDBC，如下定义： JDBC(Java DataBase Connectivity)，java数据库连接，就是 Java 语言中针对各个数据库厂商的产品各不相同，而定义的统一规范。 JDBC 是什么如前所述，JDBC 是语言规范，是 java 语言中定义的一组接口，各个数据库厂商按照这个规范，结合各自的数据库产品，实现规范中的接口。从而达到了为程序员隐藏数据库驱动实现细节的目的，java 程序员只需要调用 JDBC API 即可完成数据库连接，数据读取等操作。 数据库驱动我们安装好数据库之后，应用程序并不能直接使用数据库，必须要通过数据库驱动程序去和数据库打交道，这个数据库驱动程序，实际上就是各数据库厂商对 JDBC 接口的实现。 常用的 JDBC 接口DriverDriver 接口由数据库厂商提供，我们只需要使用 Driver 接口即可。在使用 JDBC API 连接数据库之前，必须在 DriverManager 上注册 Driver 驱动程序，以mysql为例： 1Class.forName("com.mysql.cj.jdbc.Driver"); // mysql 8.0以上 ConnectionConnection 接口与特定的数据库建立连接，然后就可以在该连接上执行数据库操作了。采用 DriverManager.getConnection(url, user, pass) 获取数据库连接： 1Connection conn = DriverManager.getConnection("jdbc:mysql://host:port/database", "user", "password"); // 其中 host 和 port为默认的话，可以省略 常用方法： createStatement()：创建执行 sql 的 statement。 prepareStatement(sql)：如上，不过该方法会预编译 sql 语句，多次执行同一 sql 语句效率会提升。 prepareCall(sql)：创建执行存储过程的callableStatement对象。 setAutoCommit(boolean autoCommit)：设置事务是否自动提交。 commit() ：在连接上提交事务。 rollback() ：在连接上回滚事务。 Statement用于执行sql语句并返回结果集。 三种Statement类： Statement：发送简单的sql语句，不带参数，有sql注入风险。 PreparedStatement：继承自Statement，可以带参数，会预编译sql语句，执行效率高，还可以防止sql注入，所以一般用该类代替Statement。 CallableStatement：继承自PreparedStatement接口，由方法prepareCall创建，用于调用存储过程。 常用方法： execute(String sql):运行语句，返回是否有结果集 executeQuery(String sql)：运行select语句，返回ResultSet结果集。 executeUpdate(String sql)：运行insert/update/delete操作，返回更新的行数。 addBatch(String sql) ：把多条sql语句放到一个批处理中。 executeBatch()：向数据库发送一批sql语句执行。 ResultSet接收由Statement执行sql语句返回的结果集。 ResultSet提供检索不同类型字段的方法，常用的有： getString(int index)、getString(String columnName)：获得在数据库里是varchar、char等类型的数据对象。 getFloat(int index)、getFloat(String columnName)：获得在数据库里是Float类型的数据对象。 getDate(int index)、getDate(String columnName)：获得在数据库里是Date类型的数据。 getBoolean(int index)、getBoolean(String columnName)：获得在数据库里是Boolean类型的数据。 getObject(int index)、getObject(String columnName)：获取在数据库里任意类型的数据。 ResultSet还提供了对结果集进行滚动的方法： next()：移动到下一行 Previous()：移动到前一行 absolute(int row)：移动到指定行 beforeFirst()：移动resultSet的最前面。 afterLast() ：移动到resultSet的最后面。 使用后依次关闭对象及连接：ResultSet → Statement → Connection。 使用JDBC的步骤注册驱动方式一： 1Class.forName("com.mysql.cj.jdbc.Driver"); 方式二： 1DriverManager.registerDriver(com.mysql.cj.jdbc.Driver); 现在一般采用方式一，为什么不采用方式二？ 原因是在JDBC规范中明确要求Driver类必须向DriverManager注册自己，即任何一个JDBCDriver的Driver类的代码都必须类似如下： 12345public classMyJDBCDriver implements Driver &#123; static&#123; DriverManager.registerDriver(new MyJDBCDriver()); &#125;&#125; 可以看到Driver在静态初始化块中已经进行了注册，如果采用方式二就会造成重复注册，从而在DriverManager中产生两个一样的驱动，并会对具体的驱动类产生依赖。而方式一中的Class.forName(String)的作用是要求JVM查找并加载指定的类，类加载到内存中时会执行静态初始化块和静态构造方法，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。 建立连接1Connection conn = DriverManager.getConnection(url, user, password); url用来标识数据库的位置，写法为： 创建执行SQL语句的Statement1234String sql = "SELECT cust_id, ? FROM customers"; // ? 表示占位符PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1, "cust_name");ResultSet rs = pstmt.executeQuery(); 处理执行结果12345while (rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString(2); System.out.println(id + " " + name);&#125; 处理完执行结果后别忘了释放资源！ 一个完整的示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;public class MysqlTest &#123; static final String DRIVER = "com.mysql.cj.jdbc.Driver"; static final String DB_URL = "jdbc:mysql:///crashcourse"; static final String USER = "tao"; static final String PASS = "qwe12345"; public static void main(String[] args) &#123; try &#123; // 注册驱动 Class.forName(DRIVER); // 建立连接 Connection conn = DriverManager.getConnection(DB_URL, USER, PASS); String sql = "SELECT customers.cust_id, ?, SUM(quantity*item_price) AS total\n" + "FROM customers, orders, orderitems\n" + "WHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num\n" + "GROUP BY customers.cust_id\n" + "ORDER BY total"; // 创建PreparedStatement PreparedStatement pstmt = conn.prepareStatement(sql); // 占位符从 1 开始 pstmt.setString(1, "cust_name"); // 执行SQL并返回结果集 ResultSet rs = pstmt.executeQuery(); // 处理结果集 while (rs.next()) &#123; //结果集的列从 1 开始 int id = rs.getInt(1); String name = rs.getString(2); Float total = rs.getFloat(3); System.out.println(id + " " + name + " " + total); &#125; // 释放资源 try &#123; rs.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pstmt.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决回文串问题的利器 Manacher 算法]]></title>
    <url>%2F2019%2F06%2F21%2FManacher%2F</url>
    <content type="text"><![CDATA[解决回文串问题的思路有不少，暴力方法和动态规划都可以解决，但是它们的时间复杂度达到了 $O(n^2)$，在某些情况下会超时。 本文介绍的 Manacher 算法仅仅只有 $O(n)$ 的时间复杂度。 处理输入字符串因为回文串有两种形式：奇回文串（如 aba），偶回文串，（ 如 aa）。为了处理上的方便，我们将输入字符串做一些特殊处理。例如串 ababac，将其处理成 $#a#b#a#b#a#c##。 处理后字符串首尾的 $ 和 # 是为了防止越界。 p 数组在这里引入一个新的辅助数组p，p[i] 表示以 i 为中心的最长回文串的半径长度，p数组的示例如下表所示： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 s_new[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 这里有一个重要结论：p[i] - 1 就是以 i 为中心的最长回文串在原串中的长度。 若 s_new[i] = ‘#’， 说明以 i 为中心的回文串在原串中是偶回文串。在 i 的一侧有相同数量的 # 和原串字符，由于对称，则任意一侧的字符总数（p[i] - 1）即为回文串在原串中的长度。若 s_new[i] != ‘#’，说明回文串在原串中是奇回文串。这时在 i 的一侧 # 的数量会比原串字符多一个，由于对称，则回文串在原串中的长度为（p[i] - 1 - 1）+ 1 = p[i] -1。 如何求 p 数组 首先引入两个变量 id，mx。id 表示目前为止右边界最远的回文串的中心，mx 表示这个最远的右边界。接着设置变量 i 遍历 s_new: 若 i &lt; mx，i 关于 id 的对称点为 j = 2 * id - i，显然 p[j] 已被求出。然后 p[i] = min(p[j], mx-i)，因为我们只能确定以 id 中心，mx - id 为半径的回文串左右两边是对称的，超出这个范围（指大于 mx 和 小于mx关于id的对称点的部分）则要手动判断，若发现以 i 为中心的回文串的右边界较 mx 更远，则更新 id 和 mx。 若 i &gt;= mx，则置 p[i] = 1，然后手动寻找以 i 为中心的回文串的边界，最后可能要更新 id 和 mx。 代码123456789101112131415161718192021222324252627public String manacher(String s)&#123; StringBuilder sb=new StringBuilder(); sb.append("$#"); for(char c:s.toCharArray())&#123; sb.append(c+"#"); &#125; sb.append('#'); int[] p=new int[sb.length()]; int id=0,mx=0; int maxLen=0,start=-1; for(int i=1;i&lt;sb.length()-1;i++)&#123; if(mx&gt;i) p[i]=Math.min(p[2*id-i],mx-i); else p[i]=1; while(sb.charAt(i+p[i])==sb.charAt(i-p[i]))&#123; p[i]++; &#125; if(i+p[i]&gt;mx)&#123; id=i; mx=i+p[i]; &#125; if(p[i]-1&gt;maxLen)&#123; maxLen=p[i]-1; start=(i-p[i])/2; &#125; &#125; return s.substring(start,start+maxLen);&#125; 时间复杂度 当右边界 mx 不需要扩展时，p[i] 可在 $O(1)$ 的时间内给出。 当右边界 mx 需要扩展时，mx 最多从 0 扩展到 n，mx 只会增加不会减少，并且每次增加时 while 循环都是从 i = mx 开始试探。 因此 Manacher 算法时间复杂度为 $O(n)$。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eratosthenes 筛法与 Euler 筛法]]></title>
    <url>%2F2019%2F06%2F19%2Fseive%2F</url>
    <content type="text"><![CDATA[求素数的方法有很多，采用暴力解法虽然可行，但是时间复杂度却达到了$O(n^2)$，稍微优化一下，使得素数的判断增长到 $\sqrt{n}$ 即可，但是这样的时间复杂度仍然有 $O(n\sqrt{n})$，显然难以令人满意。本文介绍两种比较优秀的素数筛法，Eratosthenes筛法与Euler筛法，它们的时间复杂度比暴力解法优秀的多。 Euler筛法的时间复杂度可以达到 $O(n)$，是最优秀的素数求解方法。 Eratosthenes筛法原理Eratosthenes筛法又称为埃氏筛法，它的思想非常简单：从最小的素数2开始，每当遇到一个素数，就将该素数的2倍，3倍，4倍，……，n倍筛去，这样在给定一个上界n后，就能够求出该范围内的所有素数。 代码1234567891011public void eratosthenesSeive(int n)&#123; boolean[] isPrime=new boolean[n+1]; isPrime[0]=isPrime[1]=true; for(int i=2;i&lt;=n;i++)&#123; if(!isPrime[i])&#123; for(int j=i+i;j&lt;=n;j+=i)&#123; isPrime[j]=true; &#125; &#125; &#125;&#125; 时间复杂度埃氏筛法的时间复杂度为O(nlglgn)，具体证明不在本文的讨论范围内，可以参考数论相关知识。 Euler筛法又称欧拉筛法，本文着重讲欧拉筛法，它能在线性时间复杂度内求出素数，有着极好的性能。 欧拉筛法与埃氏筛法欧拉筛法在思想上与埃氏筛法比较相近，但两者有一个区别，在埃氏筛法中，一个合数可能同时被多个素数筛去，比如28既会被2筛去又会被7筛去，这是埃氏筛法的时间复杂度不能达到O(n)的原因。欧拉筛法朝着这个目标做了一些努力，改进了一下算法，使得每个合数仅被筛去一次，于是保证了时间复杂度是线性的。 两个问题要实现欧拉筛法的想法，就必须得解决两个问题： 如何保证所有合数都会被筛去 如何保证所有合数仅被筛去一次 要解决这两个问题，我们要了解一个前提：所有合数均可被拆成若干个素数相乘。换句话说，所有的数(大于等于2)，要么是素数，要么可以表示成素数的乘积。 既然所有合数都能被表示成素数的乘积，那么解决第一个问题的方案有了：用素数筛去所有的合数。如何保证所有合数仅被筛去一次：仅用最小的素数筛去它们，第二个问题也随之迎刃而解，这就是欧拉筛法的中心思想。 代码12345678910111213141516public static void eulerSeive(int n)&#123; boolean[] isPrime=new boolean[n+1]; int[] prime=new int[n]; int cnt=0; isPrime[0]=isPrime[1]=true; for(int i=2;i&lt;=n;i++)&#123; if(!isPrime[i])&#123; prime[cnt++]=i; &#125; for(int j=0;j&lt;cnt;j++)&#123; if(i*prime[j]&gt;n) break; isPrime[i*prime[j]]=true; if(i%prime[j]==0) break; &#125; &#125;&#125; Euler筛法因为每个合数仅被筛去一次，不会造成埃氏筛法那样重复筛的问题，所以时间复杂度是O(n)。 核心代码的理解欧拉筛法的代码比较简短，但是要理解起来并不是那么容易，欧拉筛法的精华就在于下面这句： 1if(i%prime[j]==0) break; 为什么当 i % prime[j] == 0 时就要跳出内部循环呢？当循环执行到满足 i % prime[j] == 0 时，说明了一个事实：i 不能被 prime[0..j-1] 整除。也就是说，prime[j] 是 i 最小的质因子，i 应该被 prime[j] 筛去。若此时不跳出循环，循环的下一轮就要筛去 i * prime[j+1]，而且是被 prime[j+1] 筛去。另一方面 i = prime[j] * b，于是 i * prime[j+1] = prime[j] * (prime[j+1] * b)，说明应该被 prime[j] 筛去。素数数组是升序排列的，因此 i * prime[j+1] 应该仅被 prime[j] 筛去，所以必须跳出循环，否则会造成重复筛去合数的问题。 当 i % prime[j] != 0 时，继续循环会不会出错？首先 i 不能被 prime[0..j] 整除，下一轮循环中 i * prime[j+1] 也不可能被 prime[0..j] 整除，所以 i * prime[j+1] 应该被 prime[j+1] 筛去，继续循环没有问题。 总结埃氏筛法和欧拉筛法都是优秀的素数筛法，埃氏筛法思路简单，欧拉筛法效率高。当 n 较小时，不妨使用埃氏筛法；当 n 特别大时，欧拉筛法是更好的选择。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美的二叉树遍历算法 Morris Traversal]]></title>
    <url>%2F2019%2F06%2F18%2FMorries-order%2F</url>
    <content type="text"><![CDATA[传统的二叉树遍历算法有递归和非递归两种，但它们都需要O(n)的空间复杂度，在数据结构教材上似乎也默认了二叉树的遍历需要O(n)的空间复杂度，但实际上，有一种更为优秀的二叉树遍历算法，就是本文的主角——Morris Traversal。 Morris Travalsal在做到O(1)空间复杂度的同时，还能保证O(n)的时间复杂度，可谓是完美的算法。 但是要做到这点绝非易事，不能使用额外的存储空间，这就使得我们可以将目光放在书节点的空指针域上。在一棵二叉树中，n个节点含有n+1个空指针域，根据线索二叉树的思想，如果能够对其加以利用，就能实现我们的目标。事实上，要做到不使用额外的辅助空间，我们要解决一个关键的问题：那就是如何寻找到在中序序列中，当前结点的前驱结点。 先定义树结点的数据结构如下： 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 中序遍历算法 如果当前结点为null，则算法结束，遍历完成。 如果当前结点的左孩子不为null，则沿着该左孩子一直向右走到尽头(不停地访问right域，同时还要满足该结点的right域既不为null也不等于当前结点)，找到的最后一个结点即为当前结点在中序序列下的前驱结点，对此有两种情况： 如果该结点的right域不为null，则说明当前结点的左子树访问结束，访问当前结点并将前驱结点的right域置为null(复原树)，然后将当前结点的右孩子置为当前结点。 如果该结点的right域为null，则将该结点的right域指向当前结点，然后将当前结点的左孩子置为当前结点。 如果当前结点的左孩子为null，说明其没有左子树，访问当前结点，然后将当前结点的右孩子置为当前结点。 重复以上三个步骤，直到遍历结束。 这个算法的巧妙之处在于如何判断当前结点的左子树是否已经访问过，这是通过对于当前结点前驱结点的right域是否已经被设置过来判断，因为我们沿着当前结点向左下方行进时，一定会设置当前结点的前驱结点right域。当我们发现当前结点的前驱结点的right域等于当前结点时，说明左子树已经访问完毕，指针通过前驱结点的right域又回到了当前结点。按照中序遍历的定义，此时该访问当前结点了。 时间复杂度分析该算法的空间复杂度毫无疑问是O(1)，但是时间复杂度是多少呢？乍看之下，好像对于每个结点都要去寻找其前驱结点，于是时间复杂度为O(nlogn)。然而，我们注意到树中共有n-1条边，对于每条边，最多只访问3次，分别为以下情况： 沿着left域向左下方行进时 寻找当前结点的前驱结点时 确认当前结点的前驱结点right域已经被设置过了(确认左子树已经访问完毕) 因此，最多访问边3*(n-1)次，所以当n足够大的时候，时间复杂度仍然是线性的，即O(n)。 代码1234567891011121314151617181920212223public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); while(root!=null)&#123; if(root.left==null)&#123; list.add(root.val); root=root.right; &#125;else&#123; TreeNode prev=root.left; while(prev.right!=null&amp;&amp;prev.right!=root)&#123; prev=prev.right; &#125; if(prev.right==null)&#123; prev.right=root; root=root.left; &#125;else&#123; list.add(root.val); prev.right=null; root=root.right; &#125; &#125; &#125; return list;&#125; 前序遍历前序遍历和中序遍历类似，只有些许差别。 算法 如果当前结点为null，则算法结束，遍历完成。 如果当前结点的左孩子不为null，则沿着该左孩子一直向右走到尽头(不停地访问right域，同时还要满足该结点的right域既不为null也不等于当前结点)，找到的最后一个结点即为当前结点在中序序列下的前驱结点，对此有两种情况： 如果该结点的right域不为null，则说明当前结点的左子树访问结束，并将前驱结点的right域置为null(复原树)，然后将当前结点的右孩子置为当前结点。 如果该结点的right域为null，则将该结点的right域指向当前结点，并访问当前结点(和中序遍历的不同之处)，然后将当前结点的左孩子置为当前结点。 如果当前结点的左孩子为null，说明其没有左子树，访问当前结点，然后将当前结点的右孩子置为当前结点。 重复以上三个步骤，直到遍历结束。 代码1234567891011121314151617181920212223public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); while(root!=null)&#123; if(root.left==null)&#123; list.add(root.val); root=root.right; &#125;else&#123; TreeNode prev=root.left; while(prev.right!=null&amp;&amp;prev.right!=root)&#123; prev=prev.right; &#125; if(prev.right==null)&#123; list.add(root.val); prev.right=root; root=root.left; &#125;else&#123; prev.right=null; root=root.right; &#125; &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
