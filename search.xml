<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用算法模板]]></title>
    <url>%2F2019%2F12%2F03%2Falgotithm-md%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Spring Cloud Config客户端无法获取Server端的配置信息]]></title>
    <url>%2F2019%2F09%2F25%2Fconfig%2F</url>
    <content type="text"><![CDATA[问题Spring Cloud Config获取server端配置信息失败： Could not resolve placeholder 'xxxx' in value "${xxxx}" 解决方案首先保证不是由于版本冲突引起的，spring boot和spring cloud的版本要匹配，去spring官网查看spring boot和spring cloud匹配的版本，我这里是2.1.8.REALEASE和Greenwich.RELEASE。 引入config-client &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; bootstrap.yml配置获取配置文件的信息要配置在这个文件里面，因为spring boot启动是先加载bootstrap.yml，再加载application.yml，而另一方面，配置信息必须先于application.yml的内容被加载。 注册中心和spring.cloud.config.discovery配置注意，问题基本上是出在这里！注册中心必须在bootstrap.yml中配置，而且还要配置以下两项： spring: cloud: config: discovery: enabled: true service-id: cloud-config-server 因为在这里就要去发现config server，可见此时注册中心必须已经配置，从而注册中心必须在bootstrap.yml中配置。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Hystrix熔断监控出现的问题]]></title>
    <url>%2F2019%2F09%2F24%2FSpring-Cloud-Hystrix%2F</url>
    <content type="text"><![CDATA[问题Unable to connect to Command Metric Stream. 解决方法版本问题首先第一个原因可能是spring cloud的版本和Spring boot不匹配，造成了某些冲突。所以建议在pom文件中尽量不要自己写spring cloud版本号，通过dependencyManagement标签引入和当前spring boot相匹配的大版本是更好的选择。版本问题是无解的，所以要小心！ &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 端点未开放在spring boot 2.x以上版本，默认只开放了少数端点，更多的需要自己去开放。也就是说hystrix.stream这个端点未开放。 management: endpoints: web: exposure: include: "*" 配置ServletRegistrationBean在项目里配置上以下这段代码： @Bean public ServletRegistrationBean getServlet() { HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/actuator/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean; } 注意，这个方案和上一个开放端点，只需配置一个就可以解决问题]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+SpringMVC+Mybatis整合]]></title>
    <url>%2F2019%2F08%2F03%2FSSM%2F</url>
    <content type="text"><![CDATA[准备工作在开始搭建之前，有两项准备工作要做。 创建表首先在数据库中创建两张表tb_trainer和tb_pokemon： CREATE TABLE tb_trainer ( trainer_id INT NOT NULL AUTO_INCREMENT, trainer_name VARCHAR(20) NOT NULL, password VARCHAR(20) NOT NULL, age INT NOT NULL, sex INT NOT NULL, PRIMARY KEY (trainer_id) )ENGINE=InnoDB AUTO_INCREMENT=0; INSERT INTO tb_trainer(trainer_name, password, age, sex) VALUES('Tao', 'qwe12345', 20, 0); INSERT INTO tb_trainer(trainer_name, password, age, sex) VALUES('Ray', 'qwe12345', 20, 0); CREATE TABLE tb_pokemon ( pokemon_id INT NOT NULL, pokemon_name VARCHAR(20) NOT NULL, trainer_id INT NOT NULL, sex INT NOT NULL, level INT NOT NULL, PRIMARY KEY (pokemon_id) )ENGINE=InnoDB; INSERT INTO tb_pokemon(pokemon_id, pokemon_name, trainer_id, sex, level) VALUES(286, "Breloom", 1, 0, 71); INSERT INTO tb_pokemon(pokemon_id, pokemon_name, trainer_id, sex, level) VALUES(350, "Milotic", 1, 1, 71); INSERT INTO tb_pokemon(pokemon_id, pokemon_name, trainer_id, sex, level) VALUES(445, "Garchomp", 1, 0, 75); INSERT INTO tb_pokemon(pokemon_id, pokemon_name, trainer_id, sex, level) VALUES(448, "Lucario", 2, 0, 78); 引入依赖在Idea中新建Maven项目，选择maven-archetype-webapp创建一个新的工程。 创建好之后，首先在pom.xml文件中引入项目所需的依赖： &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat/tomcat-servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;9.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 然后右键点击选择Add Framework Support，勾选Spring和Spring MVC，如果没有就先去Project Setting里面把Moudules中的Spring删去，这样Idea就能识别出maven引入的Spring版本了。这时可以选择自动生成Sping配置文件，也可以选择手动创建。 从MyBatis开始搭建SSM的时候，一般从MyBatis开始，MyBatis完成的工作就是建立映射java对象和数据库表之间的映射。 创建pojo类根据创建的表，这里需要两个类Trainer和Pokemon，如下： package com.pokehunter.pojo; public class Trainer { private Integer trainerId; private String trainerName; private String password; private Integer age; private Integer sex; //省略了getter和setter @Override public String toString() { return trainerId + " " + trainerName + " " + password + " " + age + " " + sex; } } package com.pokehunter.pojo; public class Pokemon { private Integer pokemonId; private String pokemonName; private Integer trainerId; private Integer sex; private Integer level; //省略了getter和setter @Override public String toString() { return pokemonId + " " + pokemonName + " " + trainerId + " " + sex + " " + level; } } 接口定义这里需要查询tb_trainer表和tb_pokemon表，因此需要两个dao接口。 TrainerMapper接口： package com.pokehunter.dao; import com.pokehunter.pojo.Trainer; import org.apache.ibatis.annotations.Param; public interface TrainerMapper { Trainer queryTrainerByNameAndPassword(@Param("user") String userName, @Param("password") String password); } PokemonMapper接口： package com.pokehunter.dao; import com.pokehunter.pojo.Pokemon; import org.apache.ibatis.annotations.Param; import java.util.List; public interface PokemonMapper { List&lt;Pokemon&gt; queryPokemonByTrainerId(@Param("id") String trainerId); } 编写MapperMapper是定义具体sql操作的文件，有两个dao接口，可以定义两个mapper文件。TrainMapper.xml: &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.pokehunter.dao.TrainerMapper"&gt; &lt;select id="queryTrainerByNameAndPassword" resultType="Trainer"&gt; SELECT * FROM tb_trainer WHERE trainer_name = #{user} AND password = #{password} &lt;/select&gt; &lt;/mapper&gt; PokemonMapper.xml: &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.pokehunter.dao.PokemonMapper"&gt; &lt;select id="queryPokemonByTrainerId" resultType="Pokemon"&gt; SELECT p.pokemon_id, p.pokemon_name, p.trainer_id, p.sex AS sex, p.level FROM tb_trainer t INNER JOIN tb_pokemon p ON t.trainer_id = p.trainer_id WHERE t.trainer_id = ${id} &lt;/select&gt; &lt;/mapper&gt; MyBatis配置文件在resources目录下创建mybatis-config.xml配置文件： &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.pokehunter.pojo.Trainer" alias="Trainer"/&gt; &lt;typeAlias type="com.pokehunter.pojo.Pokemon" alias="Pokemon"/&gt; &lt;/typeAliases&gt; &lt;/configuration&gt; 可以看到，这里并没有配置environments和mappers，因为这些都留到了之后的Spring配置文件中去配置。 Spring配置文件Spring配置文件主要包括数据源，SqlSessionFactory，事务管理器，Mapper接口扫描等部分。如果是按webapp模版生成的工程，配置文件applicationContext.xml会默认在WEB-INF目录下，可以将它移到resources目录下，统一管理。 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:property-placeholder location="classpath:properties/db.properties" /&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="${jdbc.driver}"/&gt; &lt;property name="url" value="jdbc:mysql://${jdbc.host}:3306/${jdbc.database}?allowPublicKeyRetrieval=true"/&gt; &lt;property name="username" value="${jdbc.username}"/&gt; &lt;property name="password" value="${jdbc.password}"/&gt; &lt;property name="initialSize" value="${jdbc.initialSize}"/&gt; &lt;property name="maxActive" value="${jdbc.maxActive}"/&gt; &lt;property name="minIdle" value="${jdbc.minIdle}"/&gt; &lt;property name="maxWait" value="${jdbc.maxWait}"/&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath:mappers/*.xml"/&gt; &lt;property name="configLocation" value="classpath:/mybatis-config.xml"/&gt; &lt;/bean&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.pokehunter.dao"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt; &lt;bean id="transaction" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试Spring和MyBatis的整合及时地测试Spring和MyBatis的整合是很重要的，这样可以及时地发现并解决问题，不然等到整合了SpringMVC之后再想定位之前的问题就困难了，总结起来就是：不要让问题积累。PokemonMapperSpringTest.java文件： package com.pokehunter.dao; import com.pokehunter.pojo.Pokemon; import com.pokehunter.pojo.Trainer; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.List; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = "classpath:applicationContext.xml") public class PokemonMapperSpringTest { @Autowired private TrainerMapper trainerMapper; @Autowired private PokemonMapper pokemonMapper; @Test public void testQueryTrainerByNameAndPassword() { Trainer trainer = trainerMapper.queryTrainerByNameAndPassword("Tao", "qwe12345"); System.out.println(trainer); } @Test public void testQueryPokemonByTrainerId() { List pokemons = pokemonMapper.queryPokemonByTrainerId(2); for (Pokemon pokemon : pokemons) { System.out.println(pokemon); } } } 执行测试： 2019-08-04 23:30:32,783 [main] [org.mybatis.spring.transaction.SpringManagedTransaction]-[DEBUG] JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@53f3bdbd] will not be managed by Spring 2019-08-04 23:30:32,788 [main] [com.pokehunter.dao.TrainerMapper.queryTrainerByNameAndPassword]-[DEBUG] ==> Preparing: SELECT * FROM tb_trainer WHERE trainer_name = ? AND password = ? 2019-08-04 23:30:32,814 [main] [com.pokehunter.dao.TrainerMapper.queryTrainerByNameAndPassword]-[DEBUG] ==> Parameters: Tao(String), qwe12345(String) 2019-08-04 23:30:32,843 [main] [com.pokehunter.dao.TrainerMapper.queryTrainerByNameAndPassword]-[DEBUG] &lt;== Total: 1 2019-08-04 23:30:32,845 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@533bda92] 1 Tao qwe12345 20 0 2019-08-04 23:30:32,847 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test method: context [DefaultTestContext@3224f60b testClass = PokemonMapperSpringTest, testInstance = com.pokehunter.dao.PokemonMapperSpringTest@6c49835d, testMethod = testQueryTrainerByNameAndPassword@PokemonMapperSpringTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63e2203c testClass = PokemonMapperSpringTest, locations = '{classpath:applicationContext.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]. 2019-08-04 23:30:32,848 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test class: context [DefaultTestContext@3224f60b testClass = PokemonMapperSpringTest, testInstance = [null], testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63e2203c testClass = PokemonMapperSpringTest, locations = '{classpath:applicationContext.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null]. 2019-08-04 23:30:32,852 [Thread-0] [org.springframework.context.support.GenericApplicationContext]-[DEBUG] Closing org.springframework.context.support.GenericApplicationContext@4493d195, started on Sun Aug 04 23:30:31 CST 2019 2019-08-04 23:30:32,853 [Thread-0] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closing ... 2019-08-04 23:30:32,857 [Thread-0] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closed 2019-08-04 23:31:35,802 [main] [org.mybatis.spring.transaction.SpringManagedTransaction]-[DEBUG] JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@15f47664] will not be managed by Spring 2019-08-04 23:31:35,807 [main] [com.pokehunter.dao.PokemonMapper.queryPokemonByTrainerId]-[DEBUG] ==> Preparing: SELECT * FROM tb_trainer t INNER JOIN tb_pokemon p ON t.trainer_id = p.trainer_id WHERE t.trainer_id = 2 2019-08-04 23:31:35,832 [main] [com.pokehunter.dao.PokemonMapper.queryPokemonByTrainerId]-[DEBUG] ==> Parameters: 2019-08-04 23:31:35,857 [main] [com.pokehunter.dao.PokemonMapper.queryPokemonByTrainerId]-[DEBUG] &lt;== Total: 1 2019-08-04 23:31:35,859 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@533bda92] 448 Lucario 2 0 78 2019-08-04 23:31:35,861 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test method: context [DefaultTestContext@3224f60b testClass = PokemonMapperSpringTest, testInstance = com.pokehunter.dao.PokemonMapperSpringTest@6c49835d, testMethod = testQueryPokemonByTrainerId@PokemonMapperSpringTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63e2203c testClass = PokemonMapperSpringTest, locations = '{classpath:applicationContext.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]. 2019-08-04 23:31:35,862 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test class: context [DefaultTestContext@3224f60b testClass = PokemonMapperSpringTest, testInstance = [null], testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@63e2203c testClass = PokemonMapperSpringTest, locations = '{classpath:applicationContext.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null]. 2019-08-04 23:31:35,867 [Thread-0] [org.springframework.context.support.GenericApplicationContext]-[DEBUG] Closing org.springframework.context.support.GenericApplicationContext@4493d195, started on Sun Aug 04 23:31:34 CST 2019 2019-08-04 23:31:35,868 [Thread-0] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closing ... 2019-08-04 23:31:35,877 [Thread-0] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closed 可以看到，数据库访问是成功的，Spring和MyBatis的整合没有问题。 SpringMVC部分接下来的问题就是怎样将数据库中的信息以用户友好的形式呈现出来，换句话说，该考虑如何处理用户的请求并返回处理之后的视图了。是SpringMVC登场的时候了。 web.xml文件SpringMVC中最关键就是拦截用户请求并转发到对应控制器的DispatcherServlet，web.xml配置如下： &lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt; &lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置Spring配置文件的位置--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--SpringMVC配置文件位置--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!--拦截所有请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; SpringMVC配置文件SpringMVC配置文件默认是在WEB—INF目录下的dispatcher-servlet.xml文件。这里将它移动到resources目录下并重新命名，是通过init-param实现的，如果不指定该标签，默认是[servlet-name]-servlet.xml的格式。 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.pokehunter.controller"/&gt; &lt;!--视图解析器--&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;/beans&gt; 控制器Controller在com.pokehunter.controller下创建PoekemonController.java文件，内容如下： package com.pokehunter.controller; import com.pokehunter.dao.PokemonMapper; import com.pokehunter.dao.TrainerMapper; import com.pokehunter.pojo.Pokemon; import com.pokehunter.pojo.Trainer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.List; @org.springframework.stereotype.Controller public class PokemonController implements Controller { @Autowired private TrainerMapper trainerMapper; @Autowired private PokemonMapper pokemonMapper; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { return null; } @RequestMapping("/pokemons") public ModelAndView getPokemons(@RequestParam("userName") String username, @RequestParam("password") String password) { ModelAndView mav = null; Trainer trainer = this.trainerMapper.queryTrainerByNameAndPassword(username, password); if (trainer != null) { List pokemons = this.pokemonMapper.queryPokemonByTrainerId(trainer.getTrainerId()); System.out.println(pokemons.size()); mav = new ModelAndView("pokemon"); mav.addObject("pokemons", pokemons); } return mav; } } jsp页面尽管现在jsp已经过时了，但这里仍使用它作为样例。在WEB-INF目录下创建index.jsp，如果已存在则只需修改即可，输入以下内容： &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method="post" action="/pokemons"&gt; User: &lt;input type="text" name="userName"/&gt; &lt;br/&gt; Password: &lt;input type="text" name="password"/&gt;&lt;br/&gt; &lt;input type="submit" value="submit"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 该页面接收训练师名字和密码查询训练师拥有的pokemon情况。接下来是详情显示页面，在WEB-INF目录下新建pages文件夹，创建文件pokemon.jsp： &lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Pokemon&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border="1" bgcolor="#f0f0f0" width="100%"&gt; &lt;tr bgcolor="#949494"&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;trainer&lt;/th&gt;&lt;th&gt;sex&lt;/th&gt;&lt;th&gt;level&lt;/th&gt;&lt;/tr&gt; &lt;c:forEach items="${pokemons}" var="pokemon"&gt; &lt;tr align="center"&gt;&lt;td&gt;${pokemon.pokemon_id}&lt;/td&gt;&lt;td&gt;${pokemon.pokemon_name}&lt;/td&gt;&lt;td&gt;${pokemon.trainer_id}&lt;/td&gt; &lt;td&gt;${pokemon.sex}&lt;/td&gt;&lt;td&gt;${pokemon.level}&lt;/td&gt;&lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 至此，SSM的搭建工作告一段落，配置好Tomcat即可运行，输入对应的训练师名字和密码即可查询到拥有的Pokemon情况。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis数据库操作]]></title>
    <url>%2F2019%2F07%2F28%2Fmybatis%2F</url>
    <content type="text"><![CDATA[传统的JDBC操作数据库有许多局限性，比如说硬编码，数据库连接管理麻烦，sql代码和java代码耦合，手动释放资源等，最最重要的是结果集到对象的映射需要我们手动完成。MyBatis的出现解决了这些问题。 MyBatis介绍MyBatis是apache旗下的一个开源ORM框架，源于iBatis。它的原理实际上是在底层封装了JDBC，使得我们能更专注于数据库操作。另一个方面，因为MyBatis是对JDBC的封装，因此从效率的角度上来讲，JDBC &gt; Mybatis，不过这点代价是值得的。 MyBatis配置文件来看一下一般的mybatis配置文件是怎么样的： &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!--配置信息，也可以从文件中读取--&gt; &lt;properties&gt;&lt;/properties&gt; &lt;!--设置，例如开启驼峰匹配和缓存等--&gt; &lt;settings&gt;&lt;/settings&gt; &lt;!--为全路径类名设置别名等--&gt; &lt;typeAliases&gt;&lt;/typeAliases&gt; &lt;!--环境，可以配置多个--&gt; &lt;environments default="development"&gt; &lt;environment id="test"&gt; &lt;!--事务管理器，这里是JDBC类型--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--数据源--&gt; &lt;dataSource type="POOLED"&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt;&lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--sql查询包含在mapper中--&gt; &lt;mappers&gt;&lt;/mappers&gt; &lt;/configuration&gt; 这里并未对每个标签进行具体配置，旨在看清mybatis全局配置文件的结构。这里最重要的是第31行，指定了配置sql语句的mapper的位置，在后面将会看到这一点。 一个具体的例子假设数据库中有一张User表，用于存放User的各项信息，接下来看看mybatis是怎么将该表中的记录映射到内存中的对象的。 首先在pom.xml中增加依赖： &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; 创建tb_user表 CREATE TABLE tb_user ( id int NOT NULL AUTO_INCREMENT, user_name varchar(32) DEFAULT NULL, password varchar(32) DEFAULT NULL, name varchar(32) DEFAULT NULL, age int DEFAULT NULL, sex int DEFAULT NULL, birthday date DEFAULT NULL, created datetime DEFAULT NULL, updated datetime DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; 插入两条数据： INSERT INTO tb_user(user_name, password, name, age, sex, birthday, created, updated) VALUES("Garchomp", "garchomp12345", "tao", 20, 0, "1996-10-01", now(), now()); INSERT INTO tb_user(user_name, password, name, age, sex, birthday, created, updated) VALUES("Breloom", "Breloom12345", "chen", 20, 0, "1996-10-02", now(), now()); 创建pojo类创建一个pojo类User用以映射tb_user表中的记录： package com.pokehunter.pojo; import java.io.Serializable; import java.text.SimpleDateFormat; import java.util.Date; public class User implements Serializable { private Integer id; private String userName; private String password; private String name; private Integer age; private Integer sex; private Date birthday; private String created; private String updated; //省略了getter和setter方法 @Override public String toString() { return "User{ " + "id = " + id + ", " + "userName = " + userName + ", " + "password = " + password + ", " + "name = " + name + ", " + "age = " + age + ", " + "sex = " + sex + ", " + "birthday = " + new SimpleDateFormat("yyyy-MM-dd").format(birthday) + ", " + "created = " + created + ", " + "updated = " + updated + " }"; } } 创建UserDao接口 package com.pokehunter.dao; import com.pokehunter.pojo.User; import java.util.List; public interface UserDao { User queryUserById(int id); List&lt;User&gt; queryUserAll(); void insertUser(User user); void updateUser(User user); void deleteUser(int id); } 创建UserDaoMapper.xml最关键的就是mapper的创建，因为具体sql语句就是在mapper中配置的。 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!--当采用接口的动态代理时namespace应当与接口的全路径名一致--&gt; &lt;mapper namespace="com.pokehunter.dao.UserDao"&gt; &lt;!--注意这里id应当与接口中的方法名一致，当设置了别名时resultType可以不用全路径名--&gt; &lt;!--设置了typeAlias因此可以直接用别名--&gt; &lt;select id="queryUserById" resultType="User"&gt; SELECT * FROM tb_user WHERE id = #{id} &lt;/select&gt; &lt;select id="queryUserAll" resultType="com.pokehunter.pojo.User"&gt; SELECT * FROM tb_user &lt;/select&gt; &lt;insert id="insertUser" parameterType="com.pokehunter.pojo.User"&gt; INSERT INTO tb_user(user_name, password, name, age, sex, birthday, created, updated) VALUES (#{userName}, #{password}, #{name}, #{age}, #{sex}, #{birthday}, now(), now()) &lt;/insert&gt; &lt;update id="updateUser" parameterType="com.pokehunter.pojo.User"&gt; UPDATE tb_user &lt;!--suffixOverrides表示如果最后有多余的该符号时就会删去--&gt; &lt;trim prefix="set" suffixOverrides=","&gt; &lt;if test="userName != null"&gt;user_name = #{userName},&lt;/if&gt; &lt;if test="password != null"&gt;password = #{password},&lt;/if&gt; &lt;if test="name != null"&gt;name = #{name},&lt;/if&gt; &lt;if test="age != null"&gt;age = #{age},&lt;/if&gt; &lt;if test="sex != null"&gt;sex = #{sex},&lt;/if&gt; &lt;if test="birthday != null"&gt;birthday = #{birthday},&lt;/if&gt; updated = now(), &lt;/trim&gt; WHERE id = #{id} &lt;/update&gt; &lt;delete id="deleteUser"&gt; DELETE FROM tb_user WHERE id = #{id} &lt;/delete&gt; &lt;/mapper&gt; 修改mybatis-config.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;properties&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql:///ssm" /&gt; &lt;property name="username" value="tao" /&gt; &lt;property name="password" value="qwe12345" /&gt; &lt;/properties&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias type="com.pokehunter.pojo.User" alias="User" /&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;environment id="test"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql:///ssm" /&gt; &lt;property name="username" value="tao" /&gt; &lt;property name="password" value="qwe12345" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="${driver}" /&gt; &lt;property name="url" value="${url}" /&gt; &lt;property name="username" value="${username}" /&gt; &lt;property name="password" value="${password}" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mappers/UserDaoMapper.xml" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 添加log4j日志为了能更清晰地观察运行过程，有必要引入log4j依赖： &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha0&lt;/version&gt; &lt;/dependency&gt; 添加log4j.properties: log4j.rootLogger=DEBUG,A1 log4j.logger.org.apache=DEBUG log4j.appender.A1=org.apache.log4j.ConsoleAppender log4j.appender.A1.layout=org.apache.log4j.PatternLayout log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n 测试引入junit依赖： &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13-beta-3&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 编写UserDaoTest.java: package com.pokehunter.dao; import com.pokehunter.pojo.User; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Before; import org.junit.Test; import java.io.InputStream; import java.util.Date; import java.util.List; public class UserDaoTest { private UserDao userDao; private SqlSession sqlSession; @Before public void setUp() throws Exception { //加载mybatis配置文件 String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); this.sqlSession = sqlSessionFactory.openSession(); this.userDao = sqlSession.getMapper(UserDao.class); } @Test public void queryUserById() { User user = userDao.queryUserById(1); System.out.println(user); } @Test public void queryUserAll() { List&lt;User&gt; users = userDao.queryUserAll(); for (User user : users) { System.out.println(user); } } @Test public void insertUser() { User user = new User(); user.setId(4); user.setUserName("Li"); user.setPassword("54321"); user.setName("Cross"); user.setBirthday(new Date("1994/10/10")); user.setAge(20); user.setSex(0); userDao.insertUser(user); sqlSession.commit(); } @Test public void updateUser() { User user = new User(); user.setId(1); user.setUserName("Lei"); user.setName("Zeni"); userDao.updateUser(user); sqlSession.commit(); } @Test public void deleteUser() { userDao.deleteUser(4); sqlSession.commit(); } } 首先运行queryUserById()，结果如下： 2019-07-28 20:54:07,695 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-28 20:54:08,115 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-28 20:54:08,115 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-28 20:54:08,119 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-28 20:54:08,152 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 1(Integer) 2019-07-28 20:54:08,177 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 User{ id = 1, userName = Garchomp, password = garchomp12345, name = tao, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:01:15 } 运行insertUser()之后运行queryUserAll()，如下可见有3条记录了： 2019-07-28 20:57:19,762 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-28 20:57:20,195 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 285133380. 2019-07-28 20:57:20,195 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@10feca44] 2019-07-28 20:57:20,199 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Preparing: SELECT * from tb_user 2019-07-28 20:57:20,230 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Parameters: 2019-07-28 20:57:20,260 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] &lt;== Total: 3 User{ id = 1, userName = Garchomp, password = garchomp12345, name = tao, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:01:15 } User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } User{ id = 4, userName = Li, password = 54321, name = Cross, age = 20, sex = 0, birthday = 1994-10-09, created = 2019-07-28 20:55:20, updated = 2019-07-28 20:55:20 } 然后是updateUser(): 2019-07-28 20:58:38,718 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-28 20:58:39,147 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 285133380. 2019-07-28 20:58:39,147 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@10feca44] 2019-07-28 20:58:39,151 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Preparing: SELECT * from tb_user 2019-07-28 20:58:39,183 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Parameters: 2019-07-28 20:58:39,212 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] &lt;== Total: 3 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } User{ id = 4, userName = Li, password = 54321, name = Cross, age = 20, sex = 0, birthday = 1994-10-09, created = 2019-07-28 20:55:20, updated = 2019-07-28 20:55:20 } 最后测试一下删除id=4的记录，接着执行queryUserAll()： 2019-07-28 21:00:57,768 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-28 21:00:58,200 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 285133380. 2019-07-28 21:00:58,200 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@10feca44] 2019-07-28 21:00:58,205 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Preparing: SELECT * from tb_user 2019-07-28 21:00:58,237 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Parameters: 2019-07-28 21:00:58,268 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] &lt;== Total: 2 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } 总结User类就像一个容器，用于和表打交道，当要存储该容器中的内容时，就从中取出然后作为一条记录放进表中；当要读取时，就从表中把查询得到的信息放入容器中。这两者之间的映射就是mybatis完成的工作，UserDao接口定义了存取User的方式，UserMapperDao.xml则实现具体的存取操作。动态代理的机制使得我们仅根据接口定义的方法就可以完成具体的数据存取，而无需手动创建类去实现该接口。不过有一点要注意，使用基于接口的动态代理时，mapper的namespace一定要等于接口的全路径名。 数据库字段名和类属性名不一致在上个例子之中，表中的有个字段是user_name，而User类中对应该字段的属性为userName，两者名字不一样，如何完成映射的呢？查看mybatis-config.xml，玄机在于下面这句： &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; 该设置表示自动将有下划线的字符串映射为符合驼峰命名规范的名字，mybatis的具体做法为：去掉下划线，将所有单词拼接在一起，从第二个单词起首字母大写。事实上，映射时字符串是大小写不敏感的，也就是说去掉下划线拼接单词后，字段名和属性名将按照大小写不敏感的方式进行匹配。 当然这种方法有局限性，当字段名和类属性名就是完全不一样时，就没辙了。因此有时需要采用以下两种方法： 在mapper中sql语句的查询操作中使用别名，将查询出的表字段名设置别名等于类属性名。 使用resultMap，这个将在之后介绍。 ${}和#{}两者都表示向sql传递参数，但是不同的是${}是直接拼接字符串，相当于Statement的处理；#{}则是先将参数加引号再去替换，相当于PreparedStatement，可以防止sql注入。 动态sql有些时候，我们需要根据输入的具体的值来构造sql语句，以下有几个常用的标签。 if假设需要根据输入的name来查找User信息，如果输入为空则输出所有User信息。 定义接口： List&lt;User&gt; queryUserList(@Param("name") String name); 编写mapper： &lt;select id="queryUserList" resultType="User"&gt; SELECT * FROM tb_user WHERE 1=1 &lt;if test="name != null and name.trim() != null"&gt; AND name LIKE '%${name}%' &lt;/if&gt; &lt;/select&gt; choose when otherwise这几个标签相当于if，else if，else的关系。假设输入的name不为空则按name查找，否则如果age不为空则按age查找，两者都为空的话就查找name=”Zeni”的User。 定义接口： List&lt;User&gt; queryUserListByNameOrAge(@Param("name") String name, @Param("age") Integer age); 编写mapper： &lt;select id="queryUserListByNameOrAge" resultType="User"&gt; SELECT * FROM tb_user WHERE 1=1 &lt;choose&gt; &lt;when test="name != null and name.trim() != ''"&gt; AND name LIKE '%${name}%' &lt;/when&gt; &lt;when test="age != null"&gt; AND age = ${age} &lt;/when&gt; &lt;otherwise&gt; AND name = 'Zeni' &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; where假设输入了name就按name查找，输入了age就按age查找，两者全输入则两者都要满足，若两者皆为空则输出所有User。 定义接口： List&lt;User&gt; queryUserListByNameAndAge(@Param("name") String name, @Param("age") Integer age); 编写mapper： &lt;select id="queryUserListByNameAndAge" resultType="User"&gt; SELECT * FROM tb_user &lt;where&gt; &lt;if test="name != null and name.trim() != ''"&gt; AND name LIKE '%${name}%' &lt;/if&gt; &lt;if test="age != null"&gt; AND age = #{age} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; foreach假设需要根据一组id查找User信息。 定义接口： List&lt;User&gt; queryUserListByIds(@Param("ids") int[] ids); 编写mapper： &lt;select id="queryUserListByIds" resultType="User"&gt; SELECT * FROM tb_user WHERE id in &lt;foreach collection="ids" item="id" open="(" close=")" separator=","&gt; ${id} &lt;/foreach&gt; &lt;/select&gt; 缓存mybatis一共有两级缓存。 一级缓存mybatis的一级缓存的作用域是Session，当openSession()后，如果执行相同的sql而且参数一致时，将直接从缓存中命中返回，而不会去操作数据库。而且一级缓存是默认开启的，并且无法关闭。 测试： @Test public void queryUserById() { System.out.println(userDao.queryUserById(1)); System.out.println(userDao.queryUserById(1)); } 运行结果： 2019-07-29 13:12:11,810 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 13:12:12,260 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 13:12:12,260 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 13:12:12,265 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 13:12:12,299 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 1(Integer) 2019-07-29 13:12:12,324 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } 另外，可以使用sqlSession.clearCache强制清除缓存： @Test public void queryUserById() { System.out.println(userDao.queryUserById(1)); this.sqlSession.clearCache(); System.out.println(userDao.queryUserById(1)); } 2019-07-29 13:39:08,298 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 13:39:08,722 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 13:39:08,723 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 13:39:08,726 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 13:39:08,756 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 1(Integer) 2019-07-29 13:39:08,779 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } 2019-07-29 13:39:08,782 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 13:39:08,782 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 1(Integer) 2019-07-29 13:39:08,784 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } 二级缓存二级缓存的作用域是一个namespace，二级缓存开启时，即使Session关闭后再打开，同一个namespace中的查询仍然可以从缓存中命中。有一点要注意，使用二级缓存必须序列化。 开启二级缓存： &lt;mapper namespace="com.pokehunter.dao.UserDao"&gt; &lt;cache /&gt; &lt;/mapper&gt; 开启二级缓存必须使用序列化： public class User implements Serializable { private static final long serialVersionUID = -8313173113713913L; } 测试： @Test public void testCache() { System.out.println(this.userDao.queryUserById(1)); this.sqlSession.close(); this.sqlSession = this.sqlSessionFactory.openSession(); this.userDao = this.sqlSession.getMapper(UserDao.class); System.out.println(this.userDao.queryUserById(1)); } 运行日志： 2019-07-29 13:30:47,240 [main] [com.pokehunter.dao.UserDao]-[DEBUG] Cache Hit Ratio [com.pokehunter.dao.UserDao]: 0.0 2019-07-29 13:30:47,246 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 13:30:47,693 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 282265585. 2019-07-29 13:30:47,693 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@10d307f1] 2019-07-29 13:30:47,697 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 13:30:47,728 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 1(Integer) 2019-07-29 13:30:47,755 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } 2019-07-29 13:30:47,762 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@10d307f1] 2019-07-29 13:30:47,762 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@10d307f1] 2019-07-29 13:30:47,762 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Returned connection 282265585 to pool. 2019-07-29 13:30:47,765 [main] [com.pokehunter.dao.UserDao]-[DEBUG] Cache Hit Ratio [com.pokehunter.dao.UserDao]: 0.5 User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } 要关闭二级缓存时要么在mapper中不开启，要么在全局mybatis配置文件中(这里关闭的话mapper中开启也没用)关闭： &lt;setting name="cacheEnabled" value="false"/&gt; 高级查询在之前的例子中，User类中的属性都不含有自定义类类型，假如类中有自定义类类型该怎么映射呢？ 表关系说明在这里引入几张表：tb_order，表示订单；tb_orderdetail，订单详情，表示每一项商品的购买情况；tb_item，表示商品信息。 CREATE TABLE tb_order ( id int NOT NULL AUTO_INCREMENT, user_id int DEFAULT NULL, order_number varchar(255) DEFAULT NULL, created datetime DEFAULT NULL, updated datetime DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; INSERT INTO tb_order VALUES (1, 2, '20190111141', '2019-07-01 19:38:35', '2019-07-01 19:38:40'); CREATE TABLE tb_item ( id int NOT NULL, itemName varchar(255) DEFAULT NULL, itemPrice decimal(10,2) DEFAULT NULL, itemDetail varchar(255) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO tb_item VALUES (1, 'Sweater', '99.00', 'On sale!'); INSERT INTO tb_item VALUES (2, 'Jeans', '129.00', 'New!'); CREATE TABLE tb_orderdetail ( detail_id int NOT NULL AUTO_INCREMENT, order_id int DEFAULT NULL, total_price decimal(10,0) DEFAULT NULL, item_id int DEFAULT NULL, status int(10) unsigned zerofill DEFAULT NULL, PRIMARY KEY (detail_id) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8; INSERT INTO tb_orderdetail VALUES (1, 1, '10000', 1, '0000000001'); INSERT INTO tb_orderdetail VALUES (2, 1, '2000', 2, '0000000000'); 创建Order类，假设Order类中有一个属性User： package com.pokehunter.pojo; import java.util.Date; import java.util.List; public class Order { private Integer id; private Long userId; private String orderNumber; private Date created; private Date updated; private User user; // 省略了getter和setter方法 @Override public String toString() { return id + " " + userId + " " + orderNumber + " " + created + " " + updated + " " + user + " " + detailList; } } 一对一查询首先新建OrderMapper接口 package com.pokehunter.dao; import com.pokehunter.pojo.Order; import org.apache.ibatis.annotations.Param; public interface OrderMapper { Order queryOrderWithUserByOrderNumber(@Param("number") String number); } 配置OrderMapper.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.pokehunter.dao.OrderMapper"&gt; &lt;!--resultMap映射Order对象与结果集--&gt; &lt;resultMap id="orderUser" type="com.pokehunter.pojo.Order" autoMapping="true"&gt; &lt;id column="id" property="id" /&gt; &lt;association property="user" javaType="User" autoMapping="true"&gt; &lt;id column="user_id" property="id" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="queryOrderWithUserByOrderNumber" resultMap="orderUser"&gt; SELECT * FROM tb_order o LEFT JOIN tb_user u ON o.user_id = u.id WHERE o.order_number = #{number} &lt;/select&gt; &lt;/mapper&gt; 测试： @Test public void queryOrderUserByOrderNumber() { Order order = orderMapper.queryOrderWithUserByOrderNumber("20190111141"); System.out.println(order.getUser()); } 2019-07-29 15:03:43,687 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 15:03:44,107 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 15:03:44,107 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 15:03:44,112 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserByOrderNumber]-[DEBUG] ==> Preparing: SELECT * FROM tb_order o LEFT JOIN tb_user u ON o.user_id = u.id WHERE o.order_number = ? 2019-07-29 15:03:44,145 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserByOrderNumber]-[DEBUG] ==> Parameters: 20190111141(String) 2019-07-29 15:03:44,176 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserByOrderNumber]-[DEBUG] &lt;== Total: 1 User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-01 19:38:35, updated = 2019-07-01 19:38:40 } 一对多查询查询订单，查询出下单人信息以及订单详情。 先在Order类中加入相应属性： public class Order { private Integer id; private Long userId; private String orderNumber; private Date created; private Date updated; private User user; private List&lt;OrderDetail&gt; detailList; //省略了getter和setter } 创建OrderDetail类 public class OrderDetail { private Integer id; private Integer orderId; private Double totalPrice; private Integer status; //省略了getter和setter @Override public String toString() { return id + " " + orderId + " " + totalPrice + " " + status; } } 接口： Order queryOrderWithUserAndDetailByOrderNumber(@Param("number") String number); 配置OrderMapper： &lt;!--resultMap可以继承--&gt; &lt;resultMap id="detail" type="com.pokehunter.pojo.Order" autoMapping="true" extends="orderUser"&gt; &lt;collection property="detailList" javaType="List" ofType="OrderDetail" autoMapping="true"&gt; &lt;id column="detail_id" property="id" /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="queryOrderWithUserAndDetailByOrderNumber" resultMap="detail"&gt; SELECT * FROM tb_order o LEFT JOIN tb_user u ON o.user_id=u.id LEFT JOIN tb_orderdetail od ON o.id=od.order_id WHERE o.order_number = #{number} &lt;/select&gt; 测试： @Test public void queryOrderWithUserAndDetailByOrderNumber() { Order order = orderMapper.queryOrderWithUserAndDetailByOrderNumber("20190111141"); System.out.println(order.getUser()); System.out.println(order.getDetailList()); } 2019-07-29 16:33:46,549 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 16:33:46,988 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 16:33:46,988 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 16:33:46,992 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserAndDetailByOrderNumber]-[DEBUG] ==> Preparing: select * from tb_order o left join tb_user u on o.user_id=u.id left join tb_orderdetail od on o.id=od.order_id where o.order_number = ? 2019-07-29 16:33:47,025 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserAndDetailByOrderNumber]-[DEBUG] ==> Parameters: 20190111141(String) 2019-07-29 16:33:47,052 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserAndDetailByOrderNumber]-[DEBUG] &lt;== Total: 2 User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-01 19:38:35, updated = 2019-07-01 19:38:40 } [1 1 10000.0 1, 2 1 2000.0 0] 多对多查询查询订单，查询出下单人信息以及订单详情和订单详情中的商品信息。 首先创建Item类： package com.pokehunter.pojo; public class Item { private Integer id; private String itemName; private Double itemPrice; private String itemDetail; //省略了getter和setter @Override public String toString() { return id + " " + itemName + " " + itemPrice + " " + itemDetail; } } 然后修改OrderDetail类： package com.pokehunter.pojo; public class OrderDetail { private Integer id; private Integer orderId; private Double totalPrice; private Integer status; private Item item; //省略了getter和setter方法 @Override public String toString() { return id + " " + orderId + " " + totalPrice + " " + status + " { " + item + " }"; } } 定义接口： Order queryOrderWithUserAndDetailItemByOrderNumber(@Param("number") String number); 配置OrderMapper： &lt;resultMap id="item" type="Order" autoMapping="true" extends="orderUser"&gt; &lt;collection property="detailList" javaType="List" ofType="OrderDetail" autoMapping="true"&gt; &lt;id column="detail_id" property="id" /&gt; &lt;association property="item" javaType="Item" autoMapping="true"&gt; &lt;id column="item_id" property="id" /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="queryOrderWithUserAndDetailItemByOrderNumber" resultMap="item"&gt; SELECT * FROM tb_order o LEFT JOIN tb_user u ON o.user_id=u.id LEFT JOIN tb_orderdetail od ON o.id=od.order_id LEFT JOIN tb_item i ON od.item_id=i.id &lt;!--小于号需要转义--&gt; WHERE o.order_number = #{number} AND od.status &lt;![CDATA[ &lt;= ]]&gt; 1 &lt;/select&gt; 测试： @Test public void queryOrderWithUserAndDetailItemByOrderNumber() { Order order = orderMapper.queryOrderWithUserAndDetailItemByOrderNumber("20190111141"); System.out.println(order.getUser()); System.out.println(order.getDetailList()); } 2019-07-29 17:07:14,022 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 17:07:14,472 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 17:07:14,473 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 17:07:14,477 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserAndDetailItemByOrderNumber]-[DEBUG] ==> Preparing: select * from tb_order o left join tb_user u on o.user_id=u.id left join tb_orderdetail od on o.id=od.order_id left join tb_item i on od.item_id=i.id where o.order_number = ? AND od.status Parameters: 20190111141(String) 2019-07-29 17:07:14,546 [main] [com.pokehunter.dao.OrderMapper.queryOrderWithUserAndDetailItemByOrderNumber]-[DEBUG] &lt;== Total: 2 User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-01 19:38:35, updated = 2019-07-01 19:38:40 } [1 1 10000.0 1 { 1 Sweater 99.0 On sale! }, 2 1 2000.0 0 { 2 Jeans 129.0 New! }] 不同表字段名相同的解决办法在进行连接查询的时候，有可能两张表的某个字段同名，这个时候mybatis的处理方式是：前面的字段覆盖后面的，也就是说如果结果集中有两个相同的字段名（比如id），则只有结果集中靠前的一个会被映射，另一个则被覆盖。 如果两个字段含义相同或者我们只需要映射前一个字段，那可以不用管；但是如果需要映射第二个字段，这个时候就需要在sql查询语句中采用取别名的方式使得结果集中不含有同名的字段，然后用resultMap手动指定映射。 延迟加载延迟加载可以推迟关联查询的执行时间，只在需要的时候进行查询。与延迟加载相关的设置： &lt;setting name="lazyLoadingEnabled" value="true" /&gt; &lt;setting name="aggressiveLazyLoading" value="false" /&gt; lazyLoadingEnabled为延迟加载开关，默认为true aggressiveLazyLoading启用时会直接加载所有懒对象属性，关闭时按需加载对象属性，默认为true 接口定义： Order queryOrderAndUserByOrderNumberLazy(@Param("number") String number); 配置OrderMapper： &lt;resultMap id="lazy" type="Order" autoMapping="true"&gt; &lt;id column="id" property="id" /&gt; &lt;!--select指定子查询，column指定子查询所需条件--&gt; &lt;association property="user" javaType="User" select="sub" column="user_id" /&gt; &lt;/resultMap&gt; &lt;select id="sub" resultType="User"&gt; SELECT * FROM tb_user WHERE id = #{id} &lt;/select&gt; &lt;select id="queryOrderAndUserByOrderNumberLazy" resultMap="lazy"&gt; SELECT * FROM tb_order WHERE order_number = #{number} &lt;/select&gt; 测试： @Test public void queryOrderAndUserByOrderNumberLazy() { Order order = orderMapper.queryOrderAndUserByOrderNumberLazy("20190111142"); System.out.println(order.getOrderNumber()); System.out.println(order.getUser()); } 2019-07-29 19:50:21,762 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 19:50:22,202 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 19:50:22,202 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 19:50:22,206 [main] [com.pokehunter.dao.OrderMapper.queryOrderAndUserByOrderNumberLazy]-[DEBUG] ==> Preparing: SELECT * FROM tb_order WHERE order_number = ? 2019-07-29 19:50:22,237 [main] [com.pokehunter.dao.OrderMapper.queryOrderAndUserByOrderNumberLazy]-[DEBUG] ==> Parameters: 20190111141(String) 2019-07-29 19:50:22,301 [main] [com.pokehunter.dao.OrderMapper.queryOrderAndUserByOrderNumberLazy]-[DEBUG] &lt;== Total: 1 20190111141 2019-07-29 19:50:22,303 [main] [com.pokehunter.dao.OrderMapper.sub]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 19:50:22,304 [main] [com.pokehunter.dao.OrderMapper.sub]-[DEBUG] ==> Parameters: 2(Integer) 2019-07-29 19:50:22,307 [main] [com.pokehunter.dao.OrderMapper.sub]-[DEBUG] &lt;== Total: 1 User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } 打开agressiveLazyLoading： &lt;setting name="aggressiveLazyLoading" value="true" /&gt; 2019-07-29 19:49:07,752 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Opening JDBC Connection 2019-07-29 19:49:08,186 [main] [org.apache.ibatis.datasource.pooled.PooledDataSource]-[DEBUG] Created connection 726181440. 2019-07-29 19:49:08,187 [main] [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-[DEBUG] Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2b48a640] 2019-07-29 19:49:08,191 [main] [com.pokehunter.dao.OrderMapper.queryOrderAndUserByOrderNumberLazy]-[DEBUG] ==> Preparing: SELECT * FROM tb_order WHERE order_number = ? 2019-07-29 19:49:08,220 [main] [com.pokehunter.dao.OrderMapper.queryOrderAndUserByOrderNumberLazy]-[DEBUG] ==> Parameters: 20190111141(String) 2019-07-29 19:49:08,280 [main] [com.pokehunter.dao.OrderMapper.queryOrderAndUserByOrderNumberLazy]-[DEBUG] &lt;== Total: 1 2019-07-29 19:49:08,282 [main] [com.pokehunter.dao.OrderMapper.sub]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 19:49:08,282 [main] [com.pokehunter.dao.OrderMapper.sub]-[DEBUG] ==> Parameters: 2(Integer) 2019-07-29 19:49:08,285 [main] [com.pokehunter.dao.OrderMapper.sub]-[DEBUG] &lt;== Total: 1 20190111141 User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } Spring整合MyBatis尽管MyBatis已经比JDBC的操作简化了很多，但是仍然有一些瑕疵，例如SqlSessionFactory必须要我们自己手动创建，要修改的话就得去改java代码，这样显然不够灵活。利用Spring的IOC可以进一步规范数据库操作。 引入依赖在pom.xml中引入依赖： &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 创建Spring配置文件对于maven项目，在src/main/resource目录下创建applicationContext-dao.xml: &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!--加载配置文件--&gt; &lt;context:property-placeholder location="classpath:properties/db.properties" /&gt; &lt;!--Druid数据库连接池--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="${jdbc.driver}" /&gt; &lt;property name="url" value="jdbc:mysql://${jdbc.host}:3306/${jdbc.database}" /&gt; &lt;property name="username" value="${jdbc.username}" /&gt; &lt;property name="password" value="${jdbc.password}" /&gt; &lt;property name="maxActive" value="${jdbc.maxActive}" /&gt; &lt;property name="initialSize" value="${jdbc.initialSize}" /&gt; &lt;property name="minIdle" value="${jdbc.minIdle}" /&gt; &lt;property name="maxWait" value="${jdbc.maxWait}" /&gt; &lt;/bean&gt; &lt;!--SqlSessionFactory--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!--mapper的位置--&gt; &lt;property name="mapperLocations" value="classpath:mappers/*.xml" /&gt; &lt;!--mybatis的其他配置，注意其中的mappers要注释掉，因为前一行已经加载了--&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;/bean&gt; &lt;!--接口的位置，指定包--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.pokehunter.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;/bean&gt; &lt;!--事务管理--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;/beans&gt; 其中db.properties内容： jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.host=localhost jdbc.database=ssm jdbc.username=tao jdbc.password=qwe12345 jdbc.initialSize=0 jdbc.maxActive=20 jdbc.minIdle=1 jdbc.maxWait=1000 另外有一点要注意，如果配置了mapperLocations就要把mybatis配置文件中的mappers相关代码注释掉，不然会因为重复加载报错，或者如果没有特殊设置可以选择不配置mybatis配置文件。 测试 package com.pokehunter.dao; import com.pokehunter.pojo.User; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import java.util.Date; import java.util.List; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations = "classpath:spring/applicationContext-dao.xml") public class UserMapperSpringTest { @Autowired private UserDao userDao; @Test public void testQueryUserById() { User user = this.userDao.queryUserById(2); System.out.println(user); user = new User(); user.setId(2); user.setUserName("Milotic"); user.setName("ray"); this.userDao.updateUser(user); System.out.println(this.userDao.queryUserById(2)); } @Test public void testQueryUserAll() { List users = this.userDao.queryUserAll(); for (User user : users) { System.out.println(user); } } } 先测试queryUserAll()，由于日志太多，这里只列出关键部分： 2019-07-29 20:58:02,806 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Preparing: SELECT * from tb_user 2019-07-29 20:58:02,830 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] ==> Parameters: 2019-07-29 20:58:02,853 [main] [com.pokehunter.dao.UserDao.queryUserAll]-[DEBUG] &lt;== Total: 2 2019-07-29 20:58:02,855 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2d29b4ee] User{ id = 1, userName = Lei, password = garchomp12345, name = Zeni, age = 20, sex = 0, birthday = 1996-10-01, created = 2019-07-28 20:01:15, updated = 2019-07-28 20:58:30 } User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } 2019-07-29 20:58:02,857 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test method: context [DefaultTestContext@5ae63ade testClass = UserMapperSpringTest, testInstance = com.pokehunter.dao.UserMapperSpringTest@551aa95a, testMethod = testQueryUserAll@UserMapperSpringTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@610694f1 testClass = UserMapperSpringTest, locations = '{classpath:spring/applicationContext-dao.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]. 2019-07-29 20:58:02,858 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test class: context [DefaultTestContext@5ae63ade testClass = UserMapperSpringTest, testInstance = [null], testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@610694f1 testClass = UserMapperSpringTest, locations = '{classpath:spring/applicationContext-dao.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null]. 2019-07-29 20:58:02,862 [Thread-1] [org.springframework.context.support.GenericApplicationContext]-[DEBUG] Closing org.springframework.context.support.GenericApplicationContext@396f6598, started on Mon Jul 29 20:58:01 CST 2019 2019-07-29 20:58:02,864 [Thread-1] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closing ... 2019-07-29 20:58:02,868 [Thread-1] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closed 再测试queryUserById()，这里中间还修改了记录，观察修改前后的变化： 2019-07-29 21:07:10,219 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 21:07:10,246 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 2(Integer) 2019-07-29 21:07:10,270 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 2019-07-29 21:07:10,272 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@565f390] User{ id = 2, userName = Breloom, password = Breloom12345, name = chen, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-28 20:01:17 } 2019-07-29 21:07:10,273 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Creating a new SqlSession 2019-07-29 21:07:10,274 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@a82c5f1] was not registered for synchronization because synchronization is not active 2019-07-29 21:07:10,292 [main] [org.springframework.jdbc.datasource.DataSourceUtils]-[DEBUG] Fetching JDBC Connection from DataSource 2019-07-29 21:07:10,292 [main] [org.mybatis.spring.transaction.SpringManagedTransaction]-[DEBUG] JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@a1f72f5] will not be managed by Spring 2019-07-29 21:07:10,293 [main] [com.pokehunter.dao.UserDao.updateUser]-[DEBUG] ==> Preparing: UPDATE tb_user set user_name = ?, name = ?, updated = now() WHERE id = ? 2019-07-29 21:07:10,293 [main] [com.pokehunter.dao.UserDao.updateUser]-[DEBUG] ==> Parameters: Milotic(String), ray(String), 2(Integer) 2019-07-29 21:07:10,296 [main] [com.pokehunter.dao.UserDao.updateUser]-[DEBUG] &lt;== Updates: 1 2019-07-29 21:07:10,296 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@a82c5f1] 2019-07-29 21:07:10,296 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Creating a new SqlSession 2019-07-29 21:07:10,297 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@68f1b17f] was not registered for synchronization because synchronization is not active 2019-07-29 21:07:10,297 [main] [org.springframework.jdbc.datasource.DataSourceUtils]-[DEBUG] Fetching JDBC Connection from DataSource 2019-07-29 21:07:10,297 [main] [org.mybatis.spring.transaction.SpringManagedTransaction]-[DEBUG] JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@a1f72f5] will not be managed by Spring 2019-07-29 21:07:10,297 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Preparing: SELECT * FROM tb_user WHERE id = ? 2019-07-29 21:07:10,297 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] ==> Parameters: 2(Integer) 2019-07-29 21:07:10,299 [main] [com.pokehunter.dao.UserDao.queryUserById]-[DEBUG] &lt;== Total: 1 2019-07-29 21:07:10,299 [main] [org.mybatis.spring.SqlSessionUtils]-[DEBUG] Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@68f1b17f] User{ id = 2, userName = Milotic, password = Breloom12345, name = ray, age = 20, sex = 0, birthday = 1996-10-02, created = 2019-07-28 20:01:17, updated = 2019-07-29 21:07:10 } 2019-07-29 21:07:10,300 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test method: context [DefaultTestContext@5ae63ade testClass = UserMapperSpringTest, testInstance = com.pokehunter.dao.UserMapperSpringTest@551aa95a, testMethod = testQueryUserById@UserMapperSpringTest, testException = [null], mergedContextConfiguration = [MergedContextConfiguration@610694f1 testClass = UserMapperSpringTest, locations = '{classpath:spring/applicationContext-dao.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null], method annotated with @DirtiesContext [false] with mode [null]. 2019-07-29 21:07:10,301 [main] [org.springframework.test.context.support.AbstractDirtiesContextTestExecutionListener]-[DEBUG] After test class: context [DefaultTestContext@5ae63ade testClass = UserMapperSpringTest, testInstance = [null], testMethod = [null], testException = [null], mergedContextConfiguration = [MergedContextConfiguration@610694f1 testClass = UserMapperSpringTest, locations = '{classpath:spring/applicationContext-dao.xml}', classes = '{}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextCustomizers = set[[empty]], contextLoader = 'org.springframework.test.context.support.DelegatingSmartContextLoader', parent = [null]], attributes = map[[empty]]], class annotated with @DirtiesContext [false] with mode [null]. 2019-07-29 21:07:10,305 [Thread-1] [org.springframework.context.support.GenericApplicationContext]-[DEBUG] Closing org.springframework.context.support.GenericApplicationContext@396f6598, started on Mon Jul 29 21:07:09 CST 2019 2019-07-29 21:07:10,306 [Thread-1] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closing ... 2019-07-29 21:07:10,311 [Thread-1] [com.alibaba.druid.pool.DruidDataSource]-[INFO] {dataSource-1} closed]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化]]></title>
    <url>%2F2019%2F07%2F22%2Fserialize%2F</url>
    <content type="text"><![CDATA[Java序列化在网络传输中经常用到，除此之外有时也用于将对象保存至文件中，例如将从数据库中读取的对象保存到硬盘中以减少数据库的查询次数，实现了缓存的目的。 Serializable接口java 中只要实现了 Serializable 这个标记接口就可以序列化。 public class SerializeClass implements Serializable {...} Java序列化首先创建一个Student类: public class Student implements Serializable { private int id; private String name; private String phoneNumber; public Student(int id, String name, String phoneNumber) { this.id = id; this.name = name; this.phoneNumber = phoneNumber; } @Override public String toString() { return id + " " + name + " " + phoneNumber; } } 序列化的代码如下： public class TestSerialize { public static void main(String[] args) throws Exception { Student stu = new Student(1001, "qwe", "13334560987"); System.out.println(stu); //对象保存的文件路径 String path = "/Users/raytao/mySerial.txt"; //ObjectOutputStream和ObjectInputStream处理序列化与反序列化 ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(path)); output.writeObject(stu); } } Java反序列化反序列化的过程与序列化类似，只不过执行反序列化的类变成了 ObjectInputStream。 public class TestSerialize { public static void main(String[] args) throws Exception { String path = "/Users/raytao/mySerial.txt"; ObjectInputStream input = new ObjectInputStream(new FileInputStream(path)); //readObject()执行反序列化 stu = (Student) input.readObject(); System.out.println(stu); } } serialVersionUID属性如果序列化一个对象以后该类的结构发生了变化，那么反序列化时会出现什么情况呢？ 在 Student 类中添加 address 属性: private transient int id; private String name; private String phoneNumber; private String address; 然后执行反序列化会发现报错: Exception in thread "main" java.io.InvalidClassException: Student; local class incompatible: stream classdesc serialVersionUID = 6470179443617815091, local class serialVersionUID = 7765393098516753233 错误信息说序列化前后serialVersionUID的值不一致，因为Student类的结构发生了变化，所以版本号（默认生成）当然会发生变化，从而反序列化时jvm发现存储的版本号和类中的不一致，就会报错。 所以要在Student类中显示指定serialVersionUID，这样jvm就不会自动生成了，即使类的结构变化，因为类中已经有serialVersionUID，jvm也不会再次生成。 private static final long serialVersionUID = 6470179443617815091L; private transient int id; private String name; private String phoneNumber; private String address; 这样，当对象序列化以后，不管类的结构发生什么变化，反序列化依然能够正常进行。 因为序列化对象的时候，我们无法预料到之后类的结构会不会发生变化，会发生什么变化，因此总是为要序列化的类添加serialVersionUID字段是一个好的选择。 另外要注意serialVersionUID字段的修饰符必须要是private static final long，否则不起作用。 transient关键字在序列化的过程中，有时有些属性我们并不想将其序列化保存，例如密码，否则可能会造成安全问题，transient关键字修饰的对象将不会被序列化保存。 将Student类中的id改成transient修饰： //添加transient关键字 private transient int id; private String name; private String phoneNumber; 然后将Student对象序列化和反序列化。 public class TestSerialize { public static void main(String[] args) throws Exception { Student stu = new Student(1, "qwe", "13334560987");; System.out.println(stu); String path = "/Users/raytao/mySerial.txt"; ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(path)); output.writeObject(stu); ObjectInputStream input = new ObjectInputStream(new FileInputStream(path)); stu = (Student) input.readObject(); System.out.println(stu); } } 运行后得到如下结果 1 qwe 13334560987 0 qwe 13334560987 两次id值不一致，可见被transient修饰的属性并未序列化。 被transient修饰的属性能否序列化被transient修饰的属性真的能保证无法被序列化了吗？要回答这个问题，先来看看java源码中ArrayList的序列化机制。 ArrayList的序列化 /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access 可以看到，ArrayList中的存储结构是一个被transient修饰的Object数组，而众所周知ArrayList数组毫无疑问是能序列化的，所以这似乎与前文transient不能被序列化相悖。 再继续往下看，writeObject()这个函数是用来实现序列化的： private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 注意第5行代码，该行代码调用了s的defaultWriteObject()方法，事实上，transient不能序列化是ObjectOutputStream的默认行为，但我们可以显示地指定某个属性被序列化，即使其被transient修饰也一样，如上述代码的11~13行所示。 对于11~13行代码有两点需要注意： ArrayList只序列化存储了内容的那些单元(size)，对于空单元是不序列化的 序列化是有顺序的，如同一个队列一样，先序列化的元素在readObject()中也要最先取出 序列化transient字段transient字段可以被序列化，这是我们得出的结论。如何序列化与反序列呢？其实就和ArrayList的实现机制差不多，依葫芦画瓢就行。 在Student类中添加writeObject方法和readObject方法: private void writeObject(ObjectOutputStream out) throws Exception { out.defaultWriteObject(); out.writeObject(this.id); } private void readObject(ObjectInputStream in) throws Exception { in.defaultReadObject(); this.id = (int) in.readObject(); } 在这两个方法中先是调用了默认的defaultWriteObject()和defaultReadObject()方法，然后再自行序列化与反序列化transient字段id。 再次运行，发现序列化前后id一致： 1 qwe 13334560987 1 qwe 13334560987 序列化与单例模式在一般情况下序列化工作得很好，但是有些潜在的问题不能忽略：序列化会破坏单例模式。先将Student类改造成符合单例模式的类，在类中添加以下代码: private volatile static Student instance; //双加载机制避免重排序问题 public static Student getInstance() { if (instance == null) { synchronized (Student.class) { if (instance == null) { instance = new Student(1, "qwe", "13334560987"); } } } return instance; } 将创建Student类的方式改为getInstance()获取，为此可以将构造方法声明为私有的，从而只能调用getInstance()获取对象。 Student stu = Student.getInstance(); 运行之后，好像似乎没有什么问题: 1 qwe 13334560987 1 qwe 13334560987 把Student类中的toString()方法注释掉以后再次运行 Student@5acf9800 Student@17f052a3 可以看到序列化前后是两个不同的Student对象，换句话说，反序列化的时候生成了一个新的对象，只不过把保存的数据填充进去了。这显然破坏了单例模式只能有一个实例对象的约定。 解决方法也很简单，只需要在Student类中加入readResolve()回调方法就可以了: private Object readResolve() { return instance; } 为什么这样做可以防止生成新对象？ObjectInputStream对象执行readObject()方法的时候会看类中有没有readResolve()方法，有的话就不会创建新对象。 再次运行之后观察结果： Student@5acf9800 Student@5acf9800 序列化前后是同一个对象了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet文件上传]]></title>
    <url>%2F2019%2F07%2F09%2Fupload%2F</url>
    <content type="text"><![CDATA[环境Servlet文件上传需要commons-fileupload和commons-io两个包，下载完以后导入到Idea项目中。 上传页面在WEB-INF目录下新建一个upload.jsp文件，代码如下： 12345678910111213141516&lt;%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align="center"&gt;文件上传&lt;/h1&gt;&lt;form method="post" action="/servletupload" enctype="multipart/form-data"&gt; 学号&lt;input type="text" name="id"/&gt;&lt;br/&gt; 姓名&lt;input type="text" name="name"/&gt;&lt;br/&gt; 选择文件&lt;input type="file" name="file"/&gt;&lt;br/&gt; &lt;input type="submit" value="submit"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 注意这里表单的method必须是post，因为传输的是二进制数据，而且文件是不可能添加到url后面传输的。表单中有文件传输时，enctype也必须为multipart/form-data，它表示指定传输数据为二进制类型，如图片、mp3等。 文件上传API当表单获取到用户的输入以后，转向action指定的Servlet进行后台处理。 DiskFileItemFactory存在于fileupload包下面的DiskFileItemFactory类是创建FileItem对象的工厂，可以对它进行一些配置，在解析生成FileItem对象时需要用到。这个工厂类常用的方法有： setSizeThreshold(int sizeThreshold)：设置阀值，当文件大小小于该阀值时，文件直接存到内存中；超过该阀值时，会将文件临时存储到磁盘缓冲区中。 setRepository(File repository)：指定临时文件目录，可以采用默认值System.getProperty(“java.io.tmpdir”)。 DiskFileItemFactory(int sizeThreshold, file repository)：构造方法可以接收阀值和临时文件目录。 ServletFileUpload该类负责处理上传的文件，可以将request请求中的表单输入项解析成一个个FileItem对象，然后利用FileItem对象进行后续处理。在创建ServletFileUpload对象时需要指定之前创建的工厂对象DiskFileItemFactory，以便之后解析为FileItem对象时使用。 常用的方法有： 方法 用途 boolean isMultipartContent(HttpServletRequest req) 判断上传表单是否为multipart/form-data类型 List parseRequest(HttpServletRequest req) 解析request中的表单输入项，返回一个List setFileSizeMax(long fileMaxSize) 设置上传的单个文件的最大值，单位是字节 setSizeMax(long maxSize) 设置表单数据的总大小 之所以要设置上传文件的最大值，是为了防止客户端恶意上传超大文件来浪费服务器端的存储空间。 FileItemServletFileUpload解析request后将数据封装在FileItem对象中，我们可以利用该文件来获取输入，亦或是将文件数据写入文件。注意，非文件数据也会被封装到FileItem中，只要其在表单之中。 常用方法： 方法 用途 boolean isFormField() 判断FileItem对象封装的是普通文本表单字段，还是一个文件表单字段 String getName() 获取文件上传字段的文件名，不同浏览器中获取的文件名可能不一样 write(File file) 用于将FileItem对象中的数据写入到服务器端的某个文件中 String getString() 将FileItem中保存的数据流以一个字符串形式返回 delete() 清空FileItem对象中存放的内容 后台Servlet文件上传主要分为以下3个步骤： 创建DiskFileItemFactory对象，设置阀值大小和临时文件目录。 创建ServletFileUpload对象，设置上传文件大小以及表单总大小，解析HttpServletRequest得到List对象 遍历List，对于每一个FileItem执行处理，如果是文件数据，则将其写入指定文件 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.util.List;public class UploadServlet extends HttpServlet &#123; private final String UPLOAD_DIRECTORY = "upload"; private final int MAX_FILE_SIZE = 1024*1024*40; private final int MAX_SIZE = 1024*1024*50; private final int MEMORY_THROSHOLD = 1024*1024*10; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建DiskFileItemFactory DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(MEMORY_THROSHOLD); factory.setRepository(new File(System.getProperty("java.io.tmpdir"))); //创建ServletFileUpload ServletFileUpload upload = new ServletFileUpload(factory); upload.setFileSizeMax(MAX_FILE_SIZE); upload.setSizeMax(MAX_SIZE); upload.setHeaderEncoding("UTF-8"); String uploadPath = req.getServletContext().getRealPath("/") + UPLOAD_DIRECTORY; File dir = new File(uploadPath); //不存在目录，则创建 if (!dir.exists()) &#123; dir.mkdir(); &#125; try &#123; List&lt;FileItem&gt; items = upload.parseRequest(req); //处理FileItem for (FileItem item : items) &#123; //普通文本表单字段 if (item.isFormField()) &#123; String name = item.getFieldName(); String value = item.getString("UTF-8"); System.out.println("name: " + name + ", value: " + value); &#125; else if (item.getSize() &gt; 0) &#123; String fileName = new File(item.getName()).getName(); String filePath = uploadPath + File.separator + fileName; File storeFile = new File(filePath); item.write(storeFile); req.setAttribute("message", "文件上传成功！"); &#125; else &#123; //没有上传附件的情况 req.setAttribute("message", "没有上传文件！"); &#125; &#125; &#125; catch (Exception e) &#123; req.setAttribute("message", "错误信息：" + e.getMessage()); &#125; //上传处理完毕后跳转页面 req.getServletContext().getRequestDispatcher("/message.jsp").forward(req, resp); &#125;&#125; 其他代码创建message.jsp文件并输入以下代码： 1234567891011&lt;%@page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" language="java" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Message&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 align="center"&gt;$&#123;message&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; web.xml中增加以下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;upload&lt;/servlet-name&gt; &lt;!--xxxx处填写包名--&gt; &lt;servlet-class&gt;xxxx.UploadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;upload&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletupload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 运行在Idea中运行项目(Tomcat要配置好)，然后在浏览器上输入http://localhost:8080/upload.jsp，可以看到如下界面： 点击提交后： 在Idea中可以看到文件成功上传了：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用JavaMail API发送邮件]]></title>
    <url>%2F2019%2F07%2F08%2Fjavamail%2F</url>
    <content type="text"><![CDATA[我们平时在一个网站上注册时，经常是收到一封邮件，然后获取里面的验证码或者直接点击邮件里面的链接来完成注册。这个过程是怎么实现的呢？ 回忆一下计算机网络中的邮件发送，我们是在客户端上利用smtp协议将邮件传输到smtp服务器上，然后该smtp服务器将邮件发送到目标smtp服务器上，最后收件方用IMAP或者POP3协议从其smtp服务器上拉取邮件。 环境配置首先需要下载两个jar包：Java Mail API和Java Activation Framework（JAF）。 然后分别将其导入Idea的External Libraries（本地开发）中和WEB-INF/lib（部署）文件夹下。 JavaMail APIJavaMail API主要包含4个类： Message类：javax.mail.Message类表示一封电子邮件，发送时需要先将邮件内容封装到该类中。 Transport类：javax.mail.Transport，顾名思义就是就来发送Message对象到smtp服务器上。 Session类：javax.mail.Session，主要有两个作用，一是用来配置应用程序需要的环境信息，如主机名、端口号；二是用来建立客户端与smtp服务器之间的会话信息。Message对象和Transport对象的创建都需要用到Session对象。 Store类：javax.mail.Store，接收邮件的API类，作用和发送邮件时的Transport类相对，将获取到的邮件数据封装到Message中。 创建Session对象Transport对象和Message对象均依赖于Session对象，因此我们必须首先创建Session对象。 1234567891011121314151617public Session getSession() &#123; Properties props = new Properties(); //协议 props.setProperty("mail.transport.protocol", "smtp"); //主机名 props.setProperty("mail.host", "smtp.qq.com"); //端口号，qq的smtp服务器端口号为465或587 props.setProperty("mail.smtp.port", "465"); //认证 props.setProperty("mail.smtp.auth", "true"); props.setProperty("mail.smtp.ssl.enable", "true"); //是否在控制台显示调试信息 props.setProperty("mail.debug", "true"); return Session.getInstance(props);&#125; 创建Message对象MimeBodyPart和MimeMultipartMessage对象的内容可以看成是由一个个结点组成的，这其中涉及到两个类：MimeBodyPart和MimeMultipart。 一个MimeBodyPart代表一个结点，MimeMultipart代表多个MimeBodyPart结点，这就意味着我们可以将多个MimeBodyPart结点组合成一个结点：比如正文中有多种类型的信息（文本，图片，视频等）会很有用。 此外，多个MimeBodyPart之间也可以设置关联信息，如下： 123456789101112131415+------------------------- multipart/mixed ----------------------------+| || +----------------- multipart/related ------------------+ || | | || | +----- multipart/alternative ------+ +----------+ | +------+ || | | | | 内嵌资源 | | | 附件 | || | | +------------+ +------------+ | +----------+ | +------+ || | | | 纯文本正文 | | 超文本正文 | | | || | | +------------+ +------------+ | +----------+ | +------+ || | | | | 内嵌资源 | | | 附件 | | | | +----------------------------------+ +----------+ | +------+ || | | || +------------------------------------------------------+ || |+----------------------------------------------------------------------+ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public MimeMessage getMessage(Session session, HttpServletRequest req) throws MessagingException &#123; MimeMessage message = new MimeMessage(session); //主题 message.setSubject("Subject"); message.setFrom("1034271380@qq.com"); //多个收件人用setRecipients message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress("licdftl@gmail.com")); //文本结点 MimeBodyPart text = new MimeBodyPart(); text.setContent("这是一张图片&lt;br/&gt;&lt;p&gt;&lt;img src='http://pt138cevn.bkt.clouddn.com/Celebi.png' width='200' height='200'/&gt;&lt;/p&gt;&lt;br/&gt;", "text/html; charset=UTF-8"); //当前网站的绝对路径 String curPath = req.getServletContext().getRealPath("/"); //图片结点 MimeBodyPart image = new MimeBodyPart(); DataHandler handler = new DataHandler(new FileDataSource(curPath + "WEB-INF/classes/Garchomp.png")); image.setDataHandler(handler); image.setContentID("garchomp"); //文本+图片结合 MimeMultipart content = new MimeMultipart(); content.addBodyPart(text); //图片并没有按照预期显示在正文中，而是存在于附件中，暂时还不知道为什么，图片只好先使用外链 //content.addBodyPart(image); //content.setSubType("related"); //附件结点 MimeBodyPart attach = new MimeBodyPart(); DataHandler docx = new DataHandler(new FileDataSource(curPath + "WEB-INF/classes/wiki.docx")); attach.setDataHandler(docx); //附件名字要加上后缀 attach.setFileName("MyWiki.docx"); //MimeMultipart中由MimeBodyPart组成，因此封装先前的MimeMultipart MimeBodyPart body = new MimeBodyPart(); body.setContent(content); //组合之前的MimeBodyPart MimeMultipart pub = new MimeMultipart(); pub.addBodyPart(body); pub.addBodyPart(attach); pub.setSubType("mixed"); message.setContent(pub); message.setSentDate(new Date()); return message;&#125; 这里邮件发送的是带图片和附件的邮件，除此之外还可以发送html邮件，只需要在setContent中嵌入html代码即可，另外其他Mime支持的文件也可以传输。 发送邮件发送邮件的过程就很简单了： 利用Session对象创建Transport对象 Transport对象链接smtp服务器 发送邮件 1234567891011121314151617@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Session session = getSession(); try &#123; MimeMessage message = getMessage(session, req); Transport transport = session.getTransport(); //注意这里的密码不是邮箱密码，而是授权码（qq邮箱采用） transport.connect("1034271380@qq.com", "xnrweuodmwfdbcfg"); transport.sendMessage(message, message.getAllRecipients()); transport.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 可能遇到的问题 密码：有的邮箱采用独立密码，有的采用授权码（qq邮箱） smtp服务：有的时候发送不成功，可能是因为邮箱的smtp服务没打开 收件箱收不到邮件，也许是被当成垃圾邮件拒收了，可能可以在垃圾箱中找到也可能找不到，可以换个收件箱试试]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaMail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql中where 1=1和where 1=0的作用]]></title>
    <url>%2F2019%2F07%2F02%2FMysqlWhere%2F</url>
    <content type="text"><![CDATA[有时候可以在别的代码中看到where 1=1，这究竟是什么意思，又有什么作用，本文来探讨一下这个问题。 where 1=1的应用，不是什么高级的应用，也不是所谓的智能化的构造，仅仅只是为了满足多条件查询页面中不确定的各种因素而采用的一种构造一条正确能运行的动态SQL语句的一种方法。 where 1=1的作用1=1永远成立，因此where 1=1是始终成立的。 所以SELECT * FROM table WHERE 1=1等同于SELECT * FROM table。 不用where 1=1在多条件查询中的存在的问题假如做查询页面，并且让用户自行输入查询信息email和address。则可以使用查询语句的动态构造： 1234567String sql = "SELECT * FROM table WHERE";if(email.length()&gt;0)&#123; sql=sql+" email="+'\''+email+'\'';&#125;if(address.length()&gt;0)&#123; sql=sql+" AND address="+'\''+address+'\'';&#125; 如果email为空，address不为空会出现什么情况？ 此时查询语句为SELECT * FROM table WHERE AND address=xxx，这条查询语句非法，查询出错。 如果email和address的长度均为空的话会怎么样呢？ 此时查询语句会变为：SELECT * FROM table WHERE，这显然也是一条非法的SQL语句，查询会出错。 可见，这种写法是存在一些问题的。 where 1=1的妙用稍微修改一下代码就可以避免上述错误： 1234567String sql = "SELECT * FROM table WHERE 1=1";if(email.length()&gt;0)&#123; sql=sql+" AND email="+'\''+email+'\'';&#125;if(address.length()&gt;0)&#123; sql=sql+" AND address="+'\''+address+'\'';&#125; 完美地解决了上述问题！ where 1=0where 1=0，这个条件始终不满足，结果不会返回任何数据，只有表结构，适合用来快速建表。 1CREATE TABLE newtable AS SELECT * FROM oldtable WHERE 1=0;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 连接数据库]]></title>
    <url>%2F2019%2F07%2F02%2FJDBC%2F</url>
    <content type="text"><![CDATA[数据库种类繁多，如何能有效地连接数据库？本文介绍 JDBC API 的使用方法。首先什么是 JDBC，如下定义： JDBC(Java DataBase Connectivity)，java数据库连接，就是 Java 语言中针对各个数据库厂商的产品各不相同，而定义的统一规范。 JDBC 是什么如前所述，JDBC 是语言规范，是 java 语言中定义的一组接口，各个数据库厂商按照这个规范，结合各自的数据库产品，实现规范中的接口。从而达到了为程序员隐藏数据库驱动实现细节的目的，java 程序员只需要调用 JDBC API 即可完成数据库连接，数据读取等操作。 数据库驱动我们安装好数据库之后，应用程序并不能直接使用数据库，必须要通过数据库驱动程序去和数据库打交道，这个数据库驱动程序，实际上就是各数据库厂商对 JDBC 接口的实现。 常用的 JDBC 接口DriverDriver 接口由数据库厂商提供，我们只需要使用 Driver 接口即可。在使用 JDBC API 连接数据库之前，必须在 DriverManager 上注册 Driver 驱动程序，以mysql为例： 1Class.forName("com.mysql.cj.jdbc.Driver"); // mysql 8.0以上 ConnectionConnection 接口与特定的数据库建立连接，然后就可以在该连接上执行数据库操作了。采用 DriverManager.getConnection(url, user, pass) 获取数据库连接： 1Connection conn = DriverManager.getConnection("jdbc:mysql://host:port/database", "user", "password"); // 其中 host 和 port为默认的话，可以省略 常用方法： createStatement()：创建执行 sql 的 statement。 prepareStatement(sql)：如上，不过该方法会预编译 sql 语句，多次执行同一 sql 语句效率会提升。 prepareCall(sql)：创建执行存储过程的callableStatement对象。 setAutoCommit(boolean autoCommit)：设置事务是否自动提交。 commit() ：在连接上提交事务。 rollback() ：在连接上回滚事务。 Statement用于执行sql语句并返回结果集。 三种Statement类： Statement：发送简单的sql语句，不带参数，有sql注入风险。 PreparedStatement：继承自Statement，可以带参数，会预编译sql语句，执行效率高，还可以防止sql注入，所以一般用该类代替Statement。 CallableStatement：继承自PreparedStatement接口，由方法prepareCall创建，用于调用存储过程。 常用方法： execute(String sql):运行语句，返回是否有结果集 executeQuery(String sql)：运行select语句，返回ResultSet结果集。 executeUpdate(String sql)：运行insert/update/delete操作，返回更新的行数。 addBatch(String sql) ：把多条sql语句放到一个批处理中。 executeBatch()：向数据库发送一批sql语句执行。 ResultSet接收由Statement执行sql语句返回的结果集。 ResultSet提供检索不同类型字段的方法，常用的有： getString(int index)、getString(String columnName)：获得在数据库里是varchar、char等类型的数据对象。 getFloat(int index)、getFloat(String columnName)：获得在数据库里是Float类型的数据对象。 getDate(int index)、getDate(String columnName)：获得在数据库里是Date类型的数据。 getBoolean(int index)、getBoolean(String columnName)：获得在数据库里是Boolean类型的数据。 getObject(int index)、getObject(String columnName)：获取在数据库里任意类型的数据。 ResultSet还提供了对结果集进行滚动的方法： next()：移动到下一行 Previous()：移动到前一行 absolute(int row)：移动到指定行 beforeFirst()：移动resultSet的最前面。 afterLast() ：移动到resultSet的最后面。 使用后依次关闭对象及连接：ResultSet → Statement → Connection。 使用JDBC的步骤注册驱动方式一： 1Class.forName("com.mysql.cj.jdbc.Driver"); 方式二： 1DriverManager.registerDriver(com.mysql.cj.jdbc.Driver); 现在一般采用方式一，为什么不采用方式二？ 原因是在JDBC规范中明确要求Driver类必须向DriverManager注册自己，即任何一个JDBCDriver的Driver类的代码都必须类似如下： 12345public classMyJDBCDriver implements Driver &#123; static&#123; DriverManager.registerDriver(new MyJDBCDriver()); &#125;&#125; 可以看到Driver在静态初始化块中已经进行了注册，如果采用方式二就会造成重复注册，从而在DriverManager中产生两个一样的驱动，并会对具体的驱动类产生依赖。而方式一中的Class.forName(String)的作用是要求JVM查找并加载指定的类，类加载到内存中时会执行静态初始化块和静态构造方法，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。 建立连接1Connection conn = DriverManager.getConnection(url, user, password); url用来标识数据库的位置，写法为： 创建执行SQL语句的Statement1234String sql = "SELECT cust_id, ? FROM customers"; // ? 表示占位符PreparedStatement pstmt = conn.prepareStatement(sql);pstmt.setString(1, "cust_name");ResultSet rs = pstmt.executeQuery(); 处理执行结果12345while (rs.next()) &#123; int id = rs.getInt(1); String name = rs.getString(2); System.out.println(id + " " + name);&#125; 处理完执行结果后别忘了释放资源！ 一个完整的示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;public class MysqlTest &#123; static final String DRIVER = "com.mysql.cj.jdbc.Driver"; static final String DB_URL = "jdbc:mysql:///crashcourse"; static final String USER = "tao"; static final String PASS = "qwe12345"; public static void main(String[] args) &#123; try &#123; // 注册驱动 Class.forName(DRIVER); // 建立连接 Connection conn = DriverManager.getConnection(DB_URL, USER, PASS); String sql = "SELECT customers.cust_id, ?, SUM(quantity*item_price) AS total\n" + "FROM customers, orders, orderitems\n" + "WHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num\n" + "GROUP BY customers.cust_id\n" + "ORDER BY total"; // 创建PreparedStatement PreparedStatement pstmt = conn.prepareStatement(sql); // 占位符从 1 开始 pstmt.setString(1, "cust_name"); // 执行SQL并返回结果集 ResultSet rs = pstmt.executeQuery(); // 处理结果集 while (rs.next()) &#123; //结果集的列从 1 开始 int id = rs.getInt(1); String name = rs.getString(2); Float total = rs.getFloat(3); System.out.println(id + " " + name + " " + total); &#125; // 释放资源 try &#123; rs.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pstmt.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; conn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>MySQL</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决回文串问题的利器 Manacher 算法]]></title>
    <url>%2F2019%2F06%2F21%2FManacher%2F</url>
    <content type="text"><![CDATA[解决回文串问题的思路有不少，暴力方法和动态规划都可以解决，但是它们的时间复杂度达到了 $O(n^2)$，在某些情况下会超时。 本文介绍的 Manacher 算法仅仅只有 $O(n)$ 的时间复杂度。 处理输入字符串因为回文串有两种形式：奇回文串（如 aba），偶回文串，（ 如 aa）。为了处理上的方便，我们将输入字符串做一些特殊处理。例如串 ababac，将其处理成 $#a#b#a#b#a#c##。 处理后字符串首尾的 $ 和 # 是为了防止越界。 p 数组在这里引入一个新的辅助数组p，p[i] 表示以 i 为中心的最长回文串的半径长度，p数组的示例如下表所示： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 s_new[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 这里有一个重要结论：p[i] - 1 就是以 i 为中心的最长回文串在原串中的长度。 若 s_new[i] = ‘#’， 说明以 i 为中心的回文串在原串中是偶回文串。在 i 的一侧有相同数量的 # 和原串字符，由于对称，则任意一侧的字符总数（p[i] - 1）即为回文串在原串中的长度。若 s_new[i] != ‘#’，说明回文串在原串中是奇回文串。这时在 i 的一侧 # 的数量会比原串字符多一个，由于对称，则回文串在原串中的长度为（p[i] - 1 - 1）+ 1 = p[i] -1。 如何求 p 数组 首先引入两个变量 id，mx。id 表示目前为止右边界最远的回文串的中心，mx 表示这个最远的右边界。接着设置变量 i 遍历 s_new: 若 i &lt; mx，i 关于 id 的对称点为 j = 2 * id - i，显然 p[j] 已被求出。然后 p[i] = min(p[j], mx-i)，因为我们只能确定以 id 中心，mx - id 为半径的回文串左右两边是对称的，超出这个范围（指大于 mx 和 小于mx关于id的对称点的部分）则要手动判断，若发现以 i 为中心的回文串的右边界较 mx 更远，则更新 id 和 mx。 若 i &gt;= mx，则置 p[i] = 1，然后手动寻找以 i 为中心的回文串的边界，最后可能要更新 id 和 mx。 代码123456789101112131415161718192021222324252627public String manacher(String s)&#123; StringBuilder sb=new StringBuilder(); sb.append("$#"); for(char c:s.toCharArray())&#123; sb.append(c+"#"); &#125; sb.append('#'); int[] p=new int[sb.length()]; int id=0,mx=0; int maxLen=0,start=-1; for(int i=1;i&lt;sb.length()-1;i++)&#123; if(mx&gt;i) p[i]=Math.min(p[2*id-i],mx-i); else p[i]=1; while(sb.charAt(i+p[i])==sb.charAt(i-p[i]))&#123; p[i]++; &#125; if(i+p[i]&gt;mx)&#123; id=i; mx=i+p[i]; &#125; if(p[i]-1&gt;maxLen)&#123; maxLen=p[i]-1; start=(i-p[i])/2; &#125; &#125; return s.substring(start,start+maxLen);&#125; 时间复杂度 当右边界 mx 不需要扩展时，p[i] 可在 $O(1)$ 的时间内给出。 当右边界 mx 需要扩展时，mx 最多从 0 扩展到 n，mx 只会增加不会减少，并且每次增加时 while 循环都是从 i = mx 开始试探。 因此 Manacher 算法时间复杂度为 $O(n)$。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eratosthenes 筛法与 Euler 筛法]]></title>
    <url>%2F2019%2F06%2F19%2Fseive%2F</url>
    <content type="text"><![CDATA[求素数的方法有很多，采用暴力解法虽然可行，但是时间复杂度却达到了$O(n^2)$，稍微优化一下，使得素数的判断增长到 $\sqrt{n}$ 即可，但是这样的时间复杂度仍然有 $O(n\sqrt{n})$，显然难以令人满意。本文介绍两种比较优秀的素数筛法，Eratosthenes筛法与Euler筛法，它们的时间复杂度比暴力解法优秀的多。 Euler筛法的时间复杂度可以达到 $O(n)$，是最优秀的素数求解方法。 Eratosthenes筛法原理Eratosthenes筛法又称为埃氏筛法，它的思想非常简单：从最小的素数2开始，每当遇到一个素数，就将该素数的2倍，3倍，4倍，……，n倍筛去，这样在给定一个上界n后，就能够求出该范围内的所有素数。 代码1234567891011public void eratosthenesSeive(int n)&#123; boolean[] isPrime=new boolean[n+1]; isPrime[0]=isPrime[1]=true; for(int i=2;i&lt;=n;i++)&#123; if(!isPrime[i])&#123; for(int j=i+i;j&lt;=n;j+=i)&#123; isPrime[j]=true; &#125; &#125; &#125;&#125; 时间复杂度埃氏筛法的时间复杂度为O(nlglgn)，具体证明不在本文的讨论范围内，可以参考数论相关知识。 Euler筛法又称欧拉筛法，本文着重讲欧拉筛法，它能在线性时间复杂度内求出素数，有着极好的性能。 欧拉筛法与埃氏筛法欧拉筛法在思想上与埃氏筛法比较相近，但两者有一个区别，在埃氏筛法中，一个合数可能同时被多个素数筛去，比如28既会被2筛去又会被7筛去，这是埃氏筛法的时间复杂度不能达到O(n)的原因。欧拉筛法朝着这个目标做了一些努力，改进了一下算法，使得每个合数仅被筛去一次，于是保证了时间复杂度是线性的。 两个问题要实现欧拉筛法的想法，就必须得解决两个问题： 如何保证所有合数都会被筛去 如何保证所有合数仅被筛去一次 要解决这两个问题，我们要了解一个前提：所有合数均可被拆成若干个素数相乘。换句话说，所有的数(大于等于2)，要么是素数，要么可以表示成素数的乘积。 既然所有合数都能被表示成素数的乘积，那么解决第一个问题的方案有了：用素数筛去所有的合数。如何保证所有合数仅被筛去一次：仅用最小的素数筛去它们，第二个问题也随之迎刃而解，这就是欧拉筛法的中心思想。 代码12345678910111213141516public static void eulerSeive(int n)&#123; boolean[] isPrime=new boolean[n+1]; int[] prime=new int[n]; int cnt=0; isPrime[0]=isPrime[1]=true; for(int i=2;i&lt;=n;i++)&#123; if(!isPrime[i])&#123; prime[cnt++]=i; &#125; for(int j=0;j&lt;cnt;j++)&#123; if(i*prime[j]&gt;n) break; isPrime[i*prime[j]]=true; if(i%prime[j]==0) break; &#125; &#125;&#125; Euler筛法因为每个合数仅被筛去一次，不会造成埃氏筛法那样重复筛的问题，所以时间复杂度是O(n)。 核心代码的理解欧拉筛法的代码比较简短，但是要理解起来并不是那么容易，欧拉筛法的精华就在于下面这句： 1if(i%prime[j]==0) break; 为什么当 i % prime[j] == 0 时就要跳出内部循环呢？当循环执行到满足 i % prime[j] == 0 时，说明了一个事实：i 不能被 prime[0..j-1] 整除。也就是说，prime[j] 是 i 最小的质因子，i 应该被 prime[j] 筛去。若此时不跳出循环，循环的下一轮就要筛去 i * prime[j+1]，而且是被 prime[j+1] 筛去。另一方面 i = prime[j] * b，于是 i * prime[j+1] = prime[j] * (prime[j+1] * b)，说明应该被 prime[j] 筛去。素数数组是升序排列的，因此 i * prime[j+1] 应该仅被 prime[j] 筛去，所以必须跳出循环，否则会造成重复筛去合数的问题。 当 i % prime[j] != 0 时，继续循环会不会出错？首先 i 不能被 prime[0..j] 整除，下一轮循环中 i * prime[j+1] 也不可能被 prime[0..j] 整除，所以 i * prime[j+1] 应该被 prime[j+1] 筛去，继续循环没有问题。 总结埃氏筛法和欧拉筛法都是优秀的素数筛法，埃氏筛法思路简单，欧拉筛法效率高。当 n 较小时，不妨使用埃氏筛法；当 n 特别大时，欧拉筛法是更好的选择。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美的二叉树遍历算法 Morris Traversal]]></title>
    <url>%2F2019%2F06%2F18%2FMorries-order%2F</url>
    <content type="text"><![CDATA[传统的二叉树遍历算法有递归和非递归两种，但它们都需要O(n)的空间复杂度，在数据结构教材上似乎也默认了二叉树的遍历需要O(n)的空间复杂度，但实际上，有一种更为优秀的二叉树遍历算法，就是本文的主角——Morris Traversal。 Morris Travalsal在做到O(1)空间复杂度的同时，还能保证O(n)的时间复杂度，可谓是完美的算法。 但是要做到这点绝非易事，不能使用额外的存储空间，这就使得我们可以将目光放在书节点的空指针域上。在一棵二叉树中，n个节点含有n+1个空指针域，根据线索二叉树的思想，如果能够对其加以利用，就能实现我们的目标。事实上，要做到不使用额外的辅助空间，我们要解决一个关键的问题：那就是如何寻找到在中序序列中，当前结点的前驱结点。 先定义树结点的数据结构如下： 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 中序遍历算法 如果当前结点为null，则算法结束，遍历完成。 如果当前结点的左孩子不为null，则沿着该左孩子一直向右走到尽头(不停地访问right域，同时还要满足该结点的right域既不为null也不等于当前结点)，找到的最后一个结点即为当前结点在中序序列下的前驱结点，对此有两种情况： 如果该结点的right域不为null，则说明当前结点的左子树访问结束，访问当前结点并将前驱结点的right域置为null(复原树)，然后将当前结点的右孩子置为当前结点。 如果该结点的right域为null，则将该结点的right域指向当前结点，然后将当前结点的左孩子置为当前结点。 如果当前结点的左孩子为null，说明其没有左子树，访问当前结点，然后将当前结点的右孩子置为当前结点。 重复以上三个步骤，直到遍历结束。 这个算法的巧妙之处在于如何判断当前结点的左子树是否已经访问过，这是通过对于当前结点前驱结点的right域是否已经被设置过来判断，因为我们沿着当前结点向左下方行进时，一定会设置当前结点的前驱结点right域。当我们发现当前结点的前驱结点的right域等于当前结点时，说明左子树已经访问完毕，指针通过前驱结点的right域又回到了当前结点。按照中序遍历的定义，此时该访问当前结点了。 时间复杂度分析该算法的空间复杂度毫无疑问是O(1)，但是时间复杂度是多少呢？乍看之下，好像对于每个结点都要去寻找其前驱结点，于是时间复杂度为O(nlogn)。然而，我们注意到树中共有n-1条边，对于每条边，最多只访问3次，分别为以下情况： 沿着left域向左下方行进时 寻找当前结点的前驱结点时 确认当前结点的前驱结点right域已经被设置过了(确认左子树已经访问完毕) 因此，最多访问边3*(n-1)次，所以当n足够大的时候，时间复杂度仍然是线性的，即O(n)。 代码1234567891011121314151617181920212223public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); while(root!=null)&#123; if(root.left==null)&#123; list.add(root.val); root=root.right; &#125;else&#123; TreeNode prev=root.left; while(prev.right!=null&amp;&amp;prev.right!=root)&#123; prev=prev.right; &#125; if(prev.right==null)&#123; prev.right=root; root=root.left; &#125;else&#123; list.add(root.val); prev.right=null; root=root.right; &#125; &#125; &#125; return list;&#125; 前序遍历前序遍历和中序遍历类似，只有些许差别。 算法 如果当前结点为null，则算法结束，遍历完成。 如果当前结点的左孩子不为null，则沿着该左孩子一直向右走到尽头(不停地访问right域，同时还要满足该结点的right域既不为null也不等于当前结点)，找到的最后一个结点即为当前结点在中序序列下的前驱结点，对此有两种情况： 如果该结点的right域不为null，则说明当前结点的左子树访问结束，并将前驱结点的right域置为null(复原树)，然后将当前结点的右孩子置为当前结点。 如果该结点的right域为null，则将该结点的right域指向当前结点，并访问当前结点(和中序遍历的不同之处)，然后将当前结点的左孩子置为当前结点。 如果当前结点的左孩子为null，说明其没有左子树，访问当前结点，然后将当前结点的右孩子置为当前结点。 重复以上三个步骤，直到遍历结束。 代码1234567891011121314151617181920212223public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); while(root!=null)&#123; if(root.left==null)&#123; list.add(root.val); root=root.right; &#125;else&#123; TreeNode prev=root.left; while(prev.right!=null&amp;&amp;prev.right!=root)&#123; prev=prev.right; &#125; if(prev.right==null)&#123; list.add(root.val); prev.right=root; root=root.left; &#125;else&#123; prev.right=null; root=root.right; &#125; &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
